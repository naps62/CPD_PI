<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>FVLib: include/rapidxml/rapidxml.hpp Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="../../annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="../../files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="../../globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="../../dir_f306757988eaa5f64fda7879b18d5b2b.html">include</a>      </li>
      <li><a class="el" href="../../dir_5a2b32e48fbb34ee377b68fdd8780b89.html">rapidxml</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>rapidxml.hpp</h1>  </div>
</div>
<div class="contents">
<a href="../../d7/d70/rapidxml_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#ifndef RAPIDXML_HPP_INCLUDED</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="preprocessor">#define RAPIDXML_HPP_INCLUDED</span>
<a name="l00003"></a>00003 <span class="preprocessor"></span>
<a name="l00004"></a><a class="code" href="../../d7/d70/rapidxml_8hpp.html#a674dd1ba0db34c463bbf7e37ffef7a7c">00004</a> <span class="preprocessor">#define _UNUSED(x) ((void)x)</span>
<a name="l00005"></a>00005 <span class="preprocessor"></span>
<a name="l00006"></a>00006 <span class="comment">// Copyright (C) 2006, 2009 Marcin Kalicinski</span>
<a name="l00007"></a>00007 <span class="comment">// Version 1.13</span>
<a name="l00008"></a>00008 <span class="comment">// Revision $DateTime: 2009/05/13 01:46:17 $</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment">// If standard library is disabled, user must provide implementations of required functions and typedefs</span>
<a name="l00012"></a>00012 <span class="preprocessor">#if !defined(RAPIDXML_NO_STDLIB)</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">    #include &lt;cstdlib&gt;</span>      <span class="comment">// For std::size_t</span>
<a name="l00014"></a>00014 <span class="preprocessor">    #include &lt;cassert&gt;</span>      <span class="comment">// For assert</span>
<a name="l00015"></a>00015 <span class="preprocessor">    #include &lt;new&gt;</span>          <span class="comment">// For placement new</span>
<a name="l00016"></a>00016 <span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="comment">// On MSVC, disable &quot;conditional expression is constant&quot; warning (level 4). </span>
<a name="l00019"></a>00019 <span class="comment">// This warning is almost impossible to avoid with certain types of templated code</span>
<a name="l00020"></a>00020 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(push)</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(disable:4127)   // Conditional expression is constant</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00026"></a>00026 <span class="comment">// RAPIDXML_PARSE_ERROR</span>
<a name="l00027"></a>00027     
<a name="l00028"></a>00028 <span class="preprocessor">#if defined(RAPIDXML_NO_EXCEPTIONS)</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#define RAPIDXML_PARSE_ERROR(what, where) { parse_error_handler(what, where); assert(0); }</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span>
<a name="l00032"></a>00032 <span class="keyword">namespace </span>rapidxml
<a name="l00033"></a>00033 {
<a name="l00050"></a>00050     <span class="keywordtype">void</span> parse_error_handler(<span class="keyword">const</span> <span class="keywordtype">char</span> *what, <span class="keywordtype">void</span> *where);
<a name="l00051"></a>00051 }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="preprocessor">#else</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>    
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;exception&gt;</span>    <span class="comment">// For std::exception</span>
<a name="l00056"></a>00056 
<a name="l00057"></a><a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">00057</a> <span class="preprocessor">#define RAPIDXML_PARSE_ERROR(what, where) throw parse_error(what, where)</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>
<a name="l00059"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html">00059</a> <span class="keyword">namespace </span>rapidxml
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061 
<a name="l00073"></a><a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html">00073</a>     <span class="keyword">class </span><a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html">parse_error</a>: <span class="keyword">public</span> std::exception
<a name="l00074"></a>00074     {
<a name="l00075"></a>00075     
<a name="l00076"></a>00076     <span class="keyword">public</span>:
<a name="l00077"></a>00077     
<a name="l00079"></a><a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#aea12a301271c393fb627b368fb9f35c1">00079</a>         <a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#aea12a301271c393fb627b368fb9f35c1" title="Constructs parse error.">parse_error</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#a7665c88639e7466ee1de388a4f85e6fe">what</a>, <span class="keywordtype">void</span> *<a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#af77cc23decce473c3b5682965a4e193a">where</a>)
<a name="l00080"></a>00080             : m_what(what)
<a name="l00081"></a>00081             , m_where(where)
<a name="l00082"></a>00082         {
<a name="l00083"></a>00083         }
<a name="l00084"></a>00084 
<a name="l00087"></a><a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#a7665c88639e7466ee1de388a4f85e6fe">00087</a>         <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#a7665c88639e7466ee1de388a4f85e6fe">what</a>() <span class="keyword">const</span> throw()
<a name="l00088"></a>00088         {
<a name="l00089"></a>00089             <span class="keywordflow">return</span> m_what;
<a name="l00090"></a>00090         }
<a name="l00091"></a>00091 
<a name="l00095"></a>00095         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt;
<a name="l00096"></a><a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#af77cc23decce473c3b5682965a4e193a">00096</a>         Ch *<a class="code" href="../../df/dc7/classrapidxml_1_1parse__error.html#af77cc23decce473c3b5682965a4e193a">where</a>()<span class="keyword"> const</span>
<a name="l00097"></a>00097 <span class="keyword">        </span>{
<a name="l00098"></a>00098             <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>Ch *<span class="keyword">&gt;</span>(m_where);
<a name="l00099"></a>00099         }
<a name="l00100"></a>00100 
<a name="l00101"></a>00101     <span class="keyword">private</span>:  
<a name="l00102"></a>00102 
<a name="l00103"></a>00103         <span class="keyword">const</span> <span class="keywordtype">char</span> *m_what;
<a name="l00104"></a>00104         <span class="keywordtype">void</span> *m_where;
<a name="l00105"></a>00105 
<a name="l00106"></a>00106     };
<a name="l00107"></a>00107 }
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="preprocessor">#endif</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span>
<a name="l00112"></a>00112 <span class="comment">// Pool sizes</span>
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="preprocessor">#ifndef RAPIDXML_STATIC_POOL_SIZE</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span>    <span class="comment">// Size of static memory block of memory_pool.</span>
<a name="l00116"></a>00116     <span class="comment">// Define RAPIDXML_STATIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.</span>
<a name="l00117"></a>00117     <span class="comment">// No dynamic memory allocations are performed by memory_pool until static memory is exhausted.</span>
<a name="l00118"></a><a class="code" href="../../d7/d70/rapidxml_8hpp.html#a001304844ab478e3b213749fc8d72ca2">00118</a> <span class="preprocessor">    #define RAPIDXML_STATIC_POOL_SIZE (64 * 1024)</span>
<a name="l00119"></a>00119 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00120"></a>00120 <span class="preprocessor"></span>
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef RAPIDXML_DYNAMIC_POOL_SIZE</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>    <span class="comment">// Size of dynamic memory block of memory_pool.</span>
<a name="l00123"></a>00123     <span class="comment">// Define RAPIDXML_DYNAMIC_POOL_SIZE before including rapidxml.hpp if you want to override the default value.</span>
<a name="l00124"></a>00124     <span class="comment">// After the static block is exhausted, dynamic blocks with approximately this size are allocated by memory_pool.</span>
<a name="l00125"></a><a class="code" href="../../d7/d70/rapidxml_8hpp.html#a68d5603b71691d9dd745e45159259aa3">00125</a> <span class="preprocessor">    #define RAPIDXML_DYNAMIC_POOL_SIZE (64 * 1024)</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span>
<a name="l00128"></a>00128 <span class="preprocessor">#ifndef RAPIDXML_ALIGNMENT</span>
<a name="l00129"></a>00129 <span class="preprocessor"></span>    <span class="comment">// Memory allocation alignment.</span>
<a name="l00130"></a>00130     <span class="comment">// Define RAPIDXML_ALIGNMENT before including rapidxml.hpp if you want to override the default value, which is the size of pointer.</span>
<a name="l00131"></a>00131     <span class="comment">// All memory allocations for nodes, attributes and strings will be aligned to this value.</span>
<a name="l00132"></a>00132     <span class="comment">// This must be a power of 2 and at least 1, otherwise memory_pool will not work.</span>
<a name="l00133"></a><a class="code" href="../../d7/d70/rapidxml_8hpp.html#ad3344fdba5167e17f48a8b2318731198">00133</a> <span class="preprocessor">    #define RAPIDXML_ALIGNMENT sizeof(void *)</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="keyword">namespace </span>rapidxml
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138     <span class="comment">// Forward declarations</span>
<a name="l00139"></a>00139     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt; <span class="keyword">class </span>xml_node;
<a name="l00140"></a>00140     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt; <span class="keyword">class </span>xml_attribute;
<a name="l00141"></a>00141     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt; <span class="keyword">class </span>xml_document;
<a name="l00142"></a>00142     
<a name="l00145"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">00145</a>     <span class="keyword">enum</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a>
<a name="l00146"></a>00146     {
<a name="l00147"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca4023b6a1c7059fd8fbec2112d5c35424">00147</a>         node_document,      
<a name="l00148"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca89cbeb4d28046326e4ee953d3c4047ff">00148</a>         node_element,       
<a name="l00149"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca9d669d8e1f4ba9c7eeada4c14a11ad1d">00149</a>         node_data,          
<a name="l00150"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7caccf0b363d3876a3f83ff9b1bcdaaa536">00150</a>         node_cdata,         
<a name="l00151"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca1a695e1384ec3bd4df3eff65ec609a96">00151</a>         node_comment,       
<a name="l00152"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7cafe4ca44261e5fbedf0eab43131751212">00152</a>         node_declaration,   
<a name="l00153"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7cadf5002f2efabe231bed01d16f08f832c">00153</a>         node_doctype,       
<a name="l00154"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7caeb73b472e77347b9aa89525f16493b87">00154</a>         <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7caeb73b472e77347b9aa89525f16493b87" title="A PI node. Name contains target. Value contains instructions.">node_pi</a>             
<a name="l00155"></a>00155     };
<a name="l00156"></a>00156 
<a name="l00158"></a>00158     <span class="comment">// Parsing flags</span>
<a name="l00159"></a>00159 
<a name="l00165"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#ac2d21ef14a4e8936b94aca5d38b1a74d">00165</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#ac2d21ef14a4e8936b94aca5d38b1a74d">parse_no_data_nodes</a> = 0x1;            
<a name="l00166"></a>00166 
<a name="l00174"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a00e6fea134b786ea6efeed1c8bc4a668">00174</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a00e6fea134b786ea6efeed1c8bc4a668">parse_no_element_values</a> = 0x2;
<a name="l00175"></a>00175     
<a name="l00181"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">00181</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">parse_no_string_terminators</a> = 0x4;
<a name="l00182"></a>00182     
<a name="l00188"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a89113c103ffaf77615d1aa330c8dcca8">00188</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a89113c103ffaf77615d1aa330c8dcca8">parse_no_entity_translation</a> = 0x8;
<a name="l00189"></a>00189     
<a name="l00195"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a22d4aefaceb00d7afabfef7107b108da">00195</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a22d4aefaceb00d7afabfef7107b108da">parse_no_utf8</a> = 0x10;
<a name="l00196"></a>00196     
<a name="l00202"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a999d782659513f8015ea4236e3204c42">00202</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a999d782659513f8015ea4236e3204c42">parse_declaration_node</a> = 0x20;
<a name="l00203"></a>00203     
<a name="l00209"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#ae093dd49e2f59fa39eee95f1a6568e32">00209</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#ae093dd49e2f59fa39eee95f1a6568e32">parse_comment_nodes</a> = 0x40;
<a name="l00210"></a>00210     
<a name="l00217"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a41002b49780a90a0bbcc28ce8b895fe4">00217</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a41002b49780a90a0bbcc28ce8b895fe4">parse_doctype_node</a> = 0x80;
<a name="l00218"></a>00218     
<a name="l00224"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a03fe68fcf5d28f38476e0fd31adecc4c">00224</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a03fe68fcf5d28f38476e0fd31adecc4c">parse_pi_nodes</a> = 0x100;
<a name="l00225"></a>00225     
<a name="l00232"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a7ce8f40fda68338e20b56f41e48e49f3">00232</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a7ce8f40fda68338e20b56f41e48e49f3">parse_validate_closing_tags</a> = 0x200;
<a name="l00233"></a>00233     
<a name="l00240"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a61912424b47db5038e726d4e1c22417f">00240</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a61912424b47db5038e726d4e1c22417f">parse_trim_whitespace</a> = 0x400;
<a name="l00241"></a>00241 
<a name="l00249"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a31f33885defb5176a7d99e524c35d386">00249</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a31f33885defb5176a7d99e524c35d386">parse_normalize_whitespace</a> = 0x800;
<a name="l00250"></a>00250 
<a name="l00251"></a>00251     <span class="comment">// Compound flags</span>
<a name="l00252"></a>00252     
<a name="l00261"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#acf4edf952f59eb1b6124ea37ad7da3ab">00261</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#acf4edf952f59eb1b6124ea37ad7da3ab">parse_default</a> = 0;
<a name="l00262"></a>00262     
<a name="l00271"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a45d4d8fef551beaaba23a83b847fd6a3">00271</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a45d4d8fef551beaaba23a83b847fd6a3">parse_non_destructive</a> = <a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">parse_no_string_terminators</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#a89113c103ffaf77615d1aa330c8dcca8">parse_no_entity_translation</a>;
<a name="l00272"></a>00272     
<a name="l00276"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#a64da06dfdab7c86ca954bda4fecb978f">00276</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#a64da06dfdab7c86ca954bda4fecb978f">parse_fastest</a> = <a class="code" href="../../d7/d8a/namespacerapidxml.html#a45d4d8fef551beaaba23a83b847fd6a3">parse_non_destructive</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#ac2d21ef14a4e8936b94aca5d38b1a74d">parse_no_data_nodes</a>;
<a name="l00277"></a>00277     
<a name="l00282"></a><a class="code" href="../../d7/d8a/namespacerapidxml.html#abb48dc65db75d9e49734bc5bd2fabbfc">00282</a>     <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb48dc65db75d9e49734bc5bd2fabbfc">parse_full</a> = <a class="code" href="../../d7/d8a/namespacerapidxml.html#a999d782659513f8015ea4236e3204c42">parse_declaration_node</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#ae093dd49e2f59fa39eee95f1a6568e32">parse_comment_nodes</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#a41002b49780a90a0bbcc28ce8b895fe4">parse_doctype_node</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#a03fe68fcf5d28f38476e0fd31adecc4c">parse_pi_nodes</a> | <a class="code" href="../../d7/d8a/namespacerapidxml.html#a7ce8f40fda68338e20b56f41e48e49f3">parse_validate_closing_tags</a>;
<a name="l00283"></a>00283 
<a name="l00285"></a>00285     <span class="comment">// Internals</span>
<a name="l00286"></a>00286 
<a name="l00288"></a>00288     <span class="keyword">namespace </span>internal
<a name="l00289"></a>00289     {
<a name="l00290"></a>00290 
<a name="l00291"></a>00291         <span class="comment">// Struct that contains lookup tables for the parser</span>
<a name="l00292"></a>00292         <span class="comment">// It must be a template to allow correct linking (because it has static data members, which are defined in a header file).</span>
<a name="l00293"></a>00293         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l00294"></a>00294         <span class="keyword">struct </span>lookup_tables
<a name="l00295"></a>00295         {
<a name="l00296"></a>00296             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_whitespace[256];              <span class="comment">// Whitespace table</span>
<a name="l00297"></a>00297             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_node_name[256];               <span class="comment">// Node name table</span>
<a name="l00298"></a>00298             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_text[256];                    <span class="comment">// Text table</span>
<a name="l00299"></a>00299             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_text_pure_no_ws[256];         <span class="comment">// Text table</span>
<a name="l00300"></a>00300             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_text_pure_with_ws[256];       <span class="comment">// Text table</span>
<a name="l00301"></a>00301             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_attribute_name[256];          <span class="comment">// Attribute name table</span>
<a name="l00302"></a>00302             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_attribute_data_1[256];        <span class="comment">// Attribute data table with single quote</span>
<a name="l00303"></a>00303             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_attribute_data_1_pure[256];   <span class="comment">// Attribute data table with single quote</span>
<a name="l00304"></a>00304             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_attribute_data_2[256];        <span class="comment">// Attribute data table with double quotes</span>
<a name="l00305"></a>00305             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_attribute_data_2_pure[256];   <span class="comment">// Attribute data table with double quotes</span>
<a name="l00306"></a>00306             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_digits[256];                  <span class="comment">// Digits</span>
<a name="l00307"></a>00307             <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_upcase[256];                  <span class="comment">// To uppercase conversion table for ASCII characters</span>
<a name="l00308"></a>00308         };
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <span class="comment">// Find length of the string</span>
<a name="l00311"></a>00311         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt;
<a name="l00312"></a>00312         <span class="keyword">inline</span> std::size_t measure(<span class="keyword">const</span> Ch *p)
<a name="l00313"></a>00313         {
<a name="l00314"></a>00314             <span class="keyword">const</span> Ch *tmp = p;
<a name="l00315"></a>00315             <span class="keywordflow">while</span> (*tmp) 
<a name="l00316"></a>00316                 ++tmp;
<a name="l00317"></a>00317             <span class="keywordflow">return</span> tmp - p;
<a name="l00318"></a>00318         }
<a name="l00319"></a>00319 
<a name="l00320"></a>00320         <span class="comment">// Compare strings for equality</span>
<a name="l00321"></a>00321         <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch&gt;
<a name="l00322"></a>00322         <span class="keyword">inline</span> <span class="keywordtype">bool</span> compare(<span class="keyword">const</span> Ch *p1, std::size_t size1, <span class="keyword">const</span> Ch *p2, std::size_t size2, <span class="keywordtype">bool</span> case_sensitive)
<a name="l00323"></a>00323         {
<a name="l00324"></a>00324             <span class="keywordflow">if</span> (size1 != size2)
<a name="l00325"></a>00325                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00326"></a>00326             <span class="keywordflow">if</span> (case_sensitive)
<a name="l00327"></a>00327             {
<a name="l00328"></a>00328                 <span class="keywordflow">for</span> (<span class="keyword">const</span> Ch *end = p1 + size1; p1 &lt; end; ++p1, ++p2)
<a name="l00329"></a>00329                     <span class="keywordflow">if</span> (*p1 != *p2)
<a name="l00330"></a>00330                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332             <span class="keywordflow">else</span>
<a name="l00333"></a>00333             {
<a name="l00334"></a>00334                 <span class="keywordflow">for</span> (<span class="keyword">const</span> Ch *end = p1 + size1; p1 &lt; end; ++p1, ++p2)
<a name="l00335"></a>00335                     <span class="keywordflow">if</span> (lookup_tables&lt;0&gt;::lookup_upcase[static_cast&lt;unsigned char&gt;(*p1)] != lookup_tables&lt;0&gt;::lookup_upcase[static_cast&lt;unsigned char&gt;(*p2)])
<a name="l00336"></a>00336                         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00337"></a>00337             }
<a name="l00338"></a>00338             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00339"></a>00339         }
<a name="l00340"></a>00340     }
<a name="l00342"></a>00342 
<a name="l00344"></a>00344     <span class="comment">// Memory pool</span>
<a name="l00345"></a>00345     
<a name="l00380"></a>00380     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch = <span class="keywordtype">char</span>&gt;
<a name="l00381"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html">00381</a>     <span class="keyword">class </span><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html">memory_pool</a>
<a name="l00382"></a>00382     {
<a name="l00383"></a>00383         
<a name="l00384"></a>00384     <span class="keyword">public</span>:
<a name="l00385"></a>00385 
<a name="l00387"></a>00387         <span class="keyword">typedef</span> <span class="keywordtype">void</span> *(alloc_func)(std::size_t);       <span class="comment">// Type of user-defined function used to allocate memory</span>
<a name="l00388"></a>00388         <span class="keyword">typedef</span> void (free_func)(<span class="keywordtype">void</span> *);              <span class="comment">// Type of user-defined function used to free memory</span>
<a name="l00390"></a>00390 <span class="comment"></span>        
<a name="l00392"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0b609da81dff28a19ebd704400788429">00392</a>         <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0b609da81dff28a19ebd704400788429">memory_pool</a>()
<a name="l00393"></a>00393             : m_alloc_func(0)
<a name="l00394"></a>00394             , m_free_func(0)
<a name="l00395"></a>00395         {
<a name="l00396"></a>00396             init();
<a name="l00397"></a>00397         }
<a name="l00398"></a>00398 
<a name="l00402"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0a3e82126e59e4077f41e933130bb5a0">00402</a>         <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0a3e82126e59e4077f41e933130bb5a0">~memory_pool</a>()
<a name="l00403"></a>00403         {
<a name="l00404"></a>00404             <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#aad377c835fdaed1cb2cc9df194cf84e4">clear</a>();
<a name="l00405"></a>00405         }
<a name="l00406"></a>00406 
<a name="l00417"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">00417</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> type, 
<a name="l00418"></a>00418                                     <span class="keyword">const</span> Ch *name = 0, <span class="keyword">const</span> Ch *value = 0, 
<a name="l00419"></a>00419                                     std::size_t name_size = 0, std::size_t value_size = 0)
<a name="l00420"></a>00420         {
<a name="l00421"></a>00421             <span class="keywordtype">void</span> *memory = allocate_aligned(<span class="keyword">sizeof</span>(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a>));
<a name="l00422"></a>00422             <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *node = <span class="keyword">new</span>(memory) <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a>(type);
<a name="l00423"></a>00423             <span class="keywordflow">if</span> (name)
<a name="l00424"></a>00424             {
<a name="l00425"></a>00425                 <span class="keywordflow">if</span> (name_size &gt; 0)
<a name="l00426"></a>00426                     node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(name, name_size);
<a name="l00427"></a>00427                 <span class="keywordflow">else</span>
<a name="l00428"></a>00428                     node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(name);
<a name="l00429"></a>00429             }
<a name="l00430"></a>00430             <span class="keywordflow">if</span> (value)
<a name="l00431"></a>00431             {
<a name="l00432"></a>00432                 <span class="keywordflow">if</span> (value_size &gt; 0)
<a name="l00433"></a>00433                     node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(value, value_size);
<a name="l00434"></a>00434                 <span class="keywordflow">else</span>
<a name="l00435"></a>00435                     node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(value);
<a name="l00436"></a>00436             }
<a name="l00437"></a>00437             <span class="keywordflow">return</span> node;
<a name="l00438"></a>00438         }
<a name="l00439"></a>00439 
<a name="l00449"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a3de2a66c983336e006ea3844e244ed30">00449</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a3de2a66c983336e006ea3844e244ed30">allocate_attribute</a>(<span class="keyword">const</span> Ch *name = 0, <span class="keyword">const</span> Ch *value = 0, 
<a name="l00450"></a>00450                                               std::size_t name_size = 0, std::size_t value_size = 0)
<a name="l00451"></a>00451         {
<a name="l00452"></a>00452             <span class="keywordtype">void</span> *memory = allocate_aligned(<span class="keyword">sizeof</span>(<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a>));
<a name="l00453"></a>00453             <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = <span class="keyword">new</span>(memory) <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a>;
<a name="l00454"></a>00454             <span class="keywordflow">if</span> (name)
<a name="l00455"></a>00455             {
<a name="l00456"></a>00456                 <span class="keywordflow">if</span> (name_size &gt; 0)
<a name="l00457"></a>00457                     attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(name, name_size);
<a name="l00458"></a>00458                 <span class="keywordflow">else</span>
<a name="l00459"></a>00459                     attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(name);
<a name="l00460"></a>00460             }
<a name="l00461"></a>00461             <span class="keywordflow">if</span> (value)
<a name="l00462"></a>00462             {
<a name="l00463"></a>00463                 <span class="keywordflow">if</span> (value_size &gt; 0)
<a name="l00464"></a>00464                     attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(value, value_size);
<a name="l00465"></a>00465                 <span class="keywordflow">else</span>
<a name="l00466"></a>00466                     attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(value);
<a name="l00467"></a>00467             }
<a name="l00468"></a>00468             <span class="keywordflow">return</span> attribute;
<a name="l00469"></a>00469         }
<a name="l00470"></a>00470 
<a name="l00478"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a171941b39d55b868358da97462185f58">00478</a>         Ch *<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a171941b39d55b868358da97462185f58">allocate_string</a>(<span class="keyword">const</span> Ch *source = 0, std::size_t size = 0)
<a name="l00479"></a>00479         {
<a name="l00480"></a>00480             assert(source || size);     <span class="comment">// Either source or size (or both) must be specified</span>
<a name="l00481"></a>00481             <span class="keywordflow">if</span> (size == 0)
<a name="l00482"></a>00482                 size = internal::measure(source) + 1;
<a name="l00483"></a>00483             Ch *result = <span class="keyword">static_cast&lt;</span>Ch *<span class="keyword">&gt;</span>(allocate_aligned(size * <span class="keyword">sizeof</span>(Ch)));
<a name="l00484"></a>00484             <span class="keywordflow">if</span> (source)
<a name="l00485"></a>00485                 <span class="keywordflow">for</span> (std::size_t i = 0; i &lt; size; ++i)
<a name="l00486"></a>00486                     result[i] = source[i];
<a name="l00487"></a>00487             <span class="keywordflow">return</span> result;
<a name="l00488"></a>00488         }
<a name="l00489"></a>00489 
<a name="l00499"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0a10679fc17597d339a0dc107f8a94ac">00499</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0a10679fc17597d339a0dc107f8a94ac">clone_node</a>(<span class="keyword">const</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *source, <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *result = 0)
<a name="l00500"></a>00500         {
<a name="l00501"></a>00501             <span class="comment">// Prepare result node</span>
<a name="l00502"></a>00502             <span class="keywordflow">if</span> (result)
<a name="l00503"></a>00503             {
<a name="l00504"></a>00504                 result-&gt;remove_all_attributes();
<a name="l00505"></a>00505                 result-&gt;remove_all_nodes();
<a name="l00506"></a>00506                 result-&gt;type(source-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>());
<a name="l00507"></a>00507             }
<a name="l00508"></a>00508             <span class="keywordflow">else</span>
<a name="l00509"></a>00509                 result = <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(source-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>());
<a name="l00510"></a>00510 
<a name="l00511"></a>00511             <span class="comment">// Clone name and value</span>
<a name="l00512"></a>00512             result-&gt;name(source-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(), source-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a>());
<a name="l00513"></a>00513             result-&gt;value(source-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(), source-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9fcf201ed0915ac18dd43b0b5dcfaf32">value_size</a>());
<a name="l00514"></a>00514 
<a name="l00515"></a>00515             <span class="comment">// Clone child nodes and attributes</span>
<a name="l00516"></a>00516             <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child = source-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>(); child; child = child-&gt;next_sibling())
<a name="l00517"></a>00517                 result-&gt;append_node(<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a0a10679fc17597d339a0dc107f8a94ac">clone_node</a>(child));
<a name="l00518"></a>00518             <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attr = source-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>(); attr; attr = attr-&gt;next_attribute())
<a name="l00519"></a>00519                 result-&gt;append_attribute(<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a3de2a66c983336e006ea3844e244ed30">allocate_attribute</a>(attr-&gt;name(), attr-&gt;value(), attr-&gt;name_size(), attr-&gt;value_size()));
<a name="l00520"></a>00520 
<a name="l00521"></a>00521             <span class="keywordflow">return</span> result;
<a name="l00522"></a>00522         }
<a name="l00523"></a>00523 
<a name="l00527"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#aad377c835fdaed1cb2cc9df194cf84e4">00527</a>         <span class="keywordtype">void</span> <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#aad377c835fdaed1cb2cc9df194cf84e4">clear</a>()
<a name="l00528"></a>00528         {
<a name="l00529"></a>00529             <span class="keywordflow">while</span> (m_begin != m_static_memory)
<a name="l00530"></a>00530             {
<a name="l00531"></a>00531                 <span class="keywordtype">char</span> *previous_begin = <span class="keyword">reinterpret_cast&lt;</span>header *<span class="keyword">&gt;</span>(align(m_begin))-&gt;previous_begin;
<a name="l00532"></a>00532                 <span class="keywordflow">if</span> (m_free_func)
<a name="l00533"></a>00533                     m_free_func(m_begin);
<a name="l00534"></a>00534                 <span class="keywordflow">else</span>
<a name="l00535"></a>00535                     <span class="keyword">delete</span>[] m_begin;
<a name="l00536"></a>00536                 m_begin = previous_begin;
<a name="l00537"></a>00537             }
<a name="l00538"></a>00538             init();
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540 
<a name="l00554"></a><a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a84d3d8d2cdfc00501e1dcf26d889ae03">00554</a>         <span class="keywordtype">void</span> <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a84d3d8d2cdfc00501e1dcf26d889ae03">set_allocator</a>(alloc_func *af, free_func *ff)
<a name="l00555"></a>00555         {
<a name="l00556"></a>00556             assert(m_begin == m_static_memory &amp;&amp; m_ptr == align(m_begin));    <span class="comment">// Verify that no memory is allocated yet</span>
<a name="l00557"></a>00557             m_alloc_func = af;
<a name="l00558"></a>00558             m_free_func = ff;
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keyword">private</span>:
<a name="l00562"></a>00562 
<a name="l00563"></a>00563         <span class="keyword">struct </span>header
<a name="l00564"></a>00564         {
<a name="l00565"></a>00565             <span class="keywordtype">char</span> *previous_begin;
<a name="l00566"></a>00566         };
<a name="l00567"></a>00567 
<a name="l00568"></a>00568         <span class="keywordtype">void</span> init()
<a name="l00569"></a>00569         {
<a name="l00570"></a>00570             m_begin = m_static_memory;
<a name="l00571"></a>00571             m_ptr = align(m_begin);
<a name="l00572"></a>00572             m_end = m_static_memory + <span class="keyword">sizeof</span>(m_static_memory);
<a name="l00573"></a>00573         }
<a name="l00574"></a>00574         
<a name="l00575"></a>00575         <span class="keywordtype">char</span> *align(<span class="keywordtype">char</span> *ptr)
<a name="l00576"></a>00576         {
<a name="l00577"></a>00577             std::size_t alignment = ((<a class="code" href="../../d7/d70/rapidxml_8hpp.html#ad3344fdba5167e17f48a8b2318731198">RAPIDXML_ALIGNMENT</a> - (std::size_t(ptr) &amp; (<a class="code" href="../../d7/d70/rapidxml_8hpp.html#ad3344fdba5167e17f48a8b2318731198">RAPIDXML_ALIGNMENT</a> - 1))) &amp; (<a class="code" href="../../d7/d70/rapidxml_8hpp.html#ad3344fdba5167e17f48a8b2318731198">RAPIDXML_ALIGNMENT</a> - 1));
<a name="l00578"></a>00578             <span class="keywordflow">return</span> ptr + alignment;
<a name="l00579"></a>00579         }
<a name="l00580"></a>00580         
<a name="l00581"></a>00581         <span class="keywordtype">char</span> *allocate_raw(std::size_t size)
<a name="l00582"></a>00582         {
<a name="l00583"></a>00583             <span class="comment">// Allocate</span>
<a name="l00584"></a>00584             <span class="keywordtype">void</span> *memory;   
<a name="l00585"></a>00585             <span class="keywordflow">if</span> (m_alloc_func)   <span class="comment">// Allocate memory using either user-specified allocation function or global operator new[]</span>
<a name="l00586"></a>00586             {
<a name="l00587"></a>00587                 memory = m_alloc_func(size);
<a name="l00588"></a>00588                 assert(memory); <span class="comment">// Allocator is not allowed to return 0, on failure it must either throw, stop the program or use longjmp</span>
<a name="l00589"></a>00589             }
<a name="l00590"></a>00590             <span class="keywordflow">else</span>
<a name="l00591"></a>00591             {
<a name="l00592"></a>00592                 memory = <span class="keyword">new</span> <span class="keywordtype">char</span>[size];
<a name="l00593"></a>00593 <span class="preprocessor">#ifdef RAPIDXML_NO_EXCEPTIONS</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>                <span class="keywordflow">if</span> (!memory)            <span class="comment">// If exceptions are disabled, verify memory allocation, because new will not be able to throw bad_alloc</span>
<a name="l00595"></a>00595                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;out of memory&quot;</span>, 0);
<a name="l00596"></a>00596 <span class="preprocessor">#endif</span>
<a name="l00597"></a>00597 <span class="preprocessor"></span>            }
<a name="l00598"></a>00598             <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span> *<span class="keyword">&gt;</span>(memory);
<a name="l00599"></a>00599         }
<a name="l00600"></a>00600         
<a name="l00601"></a>00601         <span class="keywordtype">void</span> *allocate_aligned(std::size_t size)
<a name="l00602"></a>00602         {
<a name="l00603"></a>00603             <span class="comment">// Calculate aligned pointer</span>
<a name="l00604"></a>00604             <span class="keywordtype">char</span> *result = align(m_ptr);
<a name="l00605"></a>00605 
<a name="l00606"></a>00606             <span class="comment">// If not enough memory left in current pool, allocate a new pool</span>
<a name="l00607"></a>00607             <span class="keywordflow">if</span> (result + size &gt; m_end)
<a name="l00608"></a>00608             {
<a name="l00609"></a>00609                 <span class="comment">// Calculate required pool size (may be bigger than RAPIDXML_DYNAMIC_POOL_SIZE)</span>
<a name="l00610"></a>00610                 std::size_t pool_size = RAPIDXML_DYNAMIC_POOL_SIZE;
<a name="l00611"></a>00611                 <span class="keywordflow">if</span> (pool_size &lt; size)
<a name="l00612"></a>00612                     pool_size = size;
<a name="l00613"></a>00613                 
<a name="l00614"></a>00614                 <span class="comment">// Allocate</span>
<a name="l00615"></a>00615                 std::size_t alloc_size = <span class="keyword">sizeof</span>(header) + (2 * <a class="code" href="../../d7/d70/rapidxml_8hpp.html#ad3344fdba5167e17f48a8b2318731198">RAPIDXML_ALIGNMENT</a> - 2) + pool_size;     <span class="comment">// 2 alignments required in worst case: one for header, one for actual allocation</span>
<a name="l00616"></a>00616                 <span class="keywordtype">char</span> *raw_memory = allocate_raw(alloc_size);
<a name="l00617"></a>00617                     
<a name="l00618"></a>00618                 <span class="comment">// Setup new pool in allocated memory</span>
<a name="l00619"></a>00619                 <span class="keywordtype">char</span> *pool = align(raw_memory);
<a name="l00620"></a>00620                 header *new_header = <span class="keyword">reinterpret_cast&lt;</span>header *<span class="keyword">&gt;</span>(pool);
<a name="l00621"></a>00621                 new_header-&gt;previous_begin = m_begin;
<a name="l00622"></a>00622                 m_begin = raw_memory;
<a name="l00623"></a>00623                 m_ptr = pool + <span class="keyword">sizeof</span>(header);
<a name="l00624"></a>00624                 m_end = raw_memory + alloc_size;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626                 <span class="comment">// Calculate aligned pointer again using new pool</span>
<a name="l00627"></a>00627                 result = align(m_ptr);
<a name="l00628"></a>00628             }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630             <span class="comment">// Update pool and return aligned pointer</span>
<a name="l00631"></a>00631             m_ptr = result + size;
<a name="l00632"></a>00632             <span class="keywordflow">return</span> result;
<a name="l00633"></a>00633         }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635         <span class="keywordtype">char</span> *m_begin;                                      <span class="comment">// Start of raw memory making up current pool</span>
<a name="l00636"></a>00636         <span class="keywordtype">char</span> *m_ptr;                                        <span class="comment">// First free byte in current pool</span>
<a name="l00637"></a>00637         <span class="keywordtype">char</span> *m_end;                                        <span class="comment">// One past last available byte in current pool</span>
<a name="l00638"></a>00638         <span class="keywordtype">char</span> m_static_memory[RAPIDXML_STATIC_POOL_SIZE];    <span class="comment">// Static raw memory</span>
<a name="l00639"></a>00639         alloc_func *m_alloc_func;                           <span class="comment">// Allocator function, or 0 if default is to be used</span>
<a name="l00640"></a>00640         free_func *m_free_func;                             <span class="comment">// Free function, or 0 if default is to be used</span>
<a name="l00641"></a>00641     };
<a name="l00642"></a>00642 
<a name="l00644"></a>00644     <span class="comment">// XML base</span>
<a name="l00645"></a>00645 
<a name="l00649"></a>00649     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch = <span class="keywordtype">char</span>&gt;
<a name="l00650"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html">00650</a>     <span class="keyword">class </span><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html">xml_base</a>
<a name="l00651"></a>00651     {
<a name="l00652"></a>00652 
<a name="l00653"></a>00653     <span class="keyword">public</span>:
<a name="l00654"></a>00654         
<a name="l00656"></a>00656         <span class="comment">// Construction &amp; destruction</span>
<a name="l00657"></a>00657     
<a name="l00658"></a>00658         <span class="comment">// Construct a base with empty name, value and parent</span>
<a name="l00659"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a23e7f7aac02d17a0a01afb597e4b966b">00659</a>         <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a23e7f7aac02d17a0a01afb597e4b966b">xml_base</a>()
<a name="l00660"></a>00660             : <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a>(0)
<a name="l00661"></a>00661             , <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a>(0)
<a name="l00662"></a>00662             , <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a>(0)
<a name="l00663"></a>00663         {
<a name="l00664"></a>00664         }
<a name="l00665"></a>00665 
<a name="l00667"></a>00667         <span class="comment">// Node data access</span>
<a name="l00668"></a>00668     
<a name="l00675"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">00675</a>         Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>()<span class="keyword"> const</span>
<a name="l00676"></a>00676 <span class="keyword">        </span>{
<a name="l00677"></a>00677             <span class="keywordflow">return</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a> ? <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a> : <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#ad96ff6b1e41dab3ff60b9bc4df769a75">nullstr</a>();
<a name="l00678"></a>00678         }
<a name="l00679"></a>00679 
<a name="l00683"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">00683</a>         std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a>()<span class="keyword"> const</span>
<a name="l00684"></a>00684 <span class="keyword">        </span>{
<a name="l00685"></a>00685             <span class="keywordflow">return</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a> ? <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a5a8c76a7274b4180213796422c4df76f">m_name_size</a> : 0;
<a name="l00686"></a>00686         }
<a name="l00687"></a>00687 
<a name="l00694"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">00694</a>         Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>()<span class="keyword"> const</span>
<a name="l00695"></a>00695 <span class="keyword">        </span>{
<a name="l00696"></a>00696             <span class="keywordflow">return</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a> ? <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a> : <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#ad96ff6b1e41dab3ff60b9bc4df769a75">nullstr</a>();
<a name="l00697"></a>00697         }
<a name="l00698"></a>00698 
<a name="l00702"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9fcf201ed0915ac18dd43b0b5dcfaf32">00702</a>         std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9fcf201ed0915ac18dd43b0b5dcfaf32">value_size</a>()<span class="keyword"> const</span>
<a name="l00703"></a>00703 <span class="keyword">        </span>{
<a name="l00704"></a>00704             <span class="keywordflow">return</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a> ? <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#aa3a49d8ceddb8a8d7edb773a2226b89c">m_value_size</a> : 0;
<a name="l00705"></a>00705         }
<a name="l00706"></a>00706 
<a name="l00708"></a>00708         <span class="comment">// Node modification</span>
<a name="l00709"></a>00709     
<a name="l00723"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#ae55060ae958c6e6465d6c8db852ec6ce">00723</a>         <span class="keywordtype">void</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>, std::size_t size)
<a name="l00724"></a>00724         {
<a name="l00725"></a>00725             <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a> = <span class="keyword">const_cast&lt;</span>Ch *<span class="keyword">&gt;</span>(name);
<a name="l00726"></a>00726             <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a5a8c76a7274b4180213796422c4df76f">m_name_size</a> = size;
<a name="l00727"></a>00727         }
<a name="l00728"></a>00728 
<a name="l00732"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a4611ddc82ac83a527c65606600eb2a0d">00732</a>         <span class="keywordtype">void</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00733"></a>00733         {
<a name="l00734"></a>00734             this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>(name, internal::measure(name));
<a name="l00735"></a>00735         }
<a name="l00736"></a>00736 
<a name="l00753"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a3b183c2db7022a6d30494dd2f0ac11e9">00753</a>         <span class="keywordtype">void</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>, std::size_t size)
<a name="l00754"></a>00754         {
<a name="l00755"></a>00755             <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a> = <span class="keyword">const_cast&lt;</span>Ch *<span class="keyword">&gt;</span>(value);
<a name="l00756"></a>00756             <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#aa3a49d8ceddb8a8d7edb773a2226b89c">m_value_size</a> = size;
<a name="l00757"></a>00757         }
<a name="l00758"></a>00758 
<a name="l00762"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a81e63ec4bfd2d7ef0a6c2ed49be6e623">00762</a>         <span class="keywordtype">void</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>)
<a name="l00763"></a>00763         {
<a name="l00764"></a>00764             this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a>(value, internal::measure(value));
<a name="l00765"></a>00765         }
<a name="l00766"></a>00766 
<a name="l00768"></a>00768         <span class="comment">// Related nodes access</span>
<a name="l00769"></a>00769     
<a name="l00772"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">00772</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>()<span class="keyword"> const</span>
<a name="l00773"></a>00773 <span class="keyword">        </span>{
<a name="l00774"></a>00774             <span class="keywordflow">return</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a>;
<a name="l00775"></a>00775         }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777     <span class="keyword">protected</span>:
<a name="l00778"></a>00778 
<a name="l00779"></a>00779         <span class="comment">// Return empty string</span>
<a name="l00780"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#ad96ff6b1e41dab3ff60b9bc4df769a75">00780</a>         <span class="keyword">static</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#ad96ff6b1e41dab3ff60b9bc4df769a75">nullstr</a>()
<a name="l00781"></a>00781         {
<a name="l00782"></a>00782             <span class="keyword">static</span> Ch zero = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l00783"></a>00783             <span class="keywordflow">return</span> &amp;zero;
<a name="l00784"></a>00784         }
<a name="l00785"></a>00785 
<a name="l00786"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">00786</a>         Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#afd9851ed43e14619db0d7075ef8e9e8a">m_name</a>;                         <span class="comment">// Name of node, or 0 if no name</span>
<a name="l00787"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">00787</a>         Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a278a1ea63b0b70219b946cec47fa00ea">m_value</a>;                        <span class="comment">// Value of node, or 0 if no value</span>
<a name="l00788"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a5a8c76a7274b4180213796422c4df76f">00788</a>         std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a5a8c76a7274b4180213796422c4df76f">m_name_size</a>;            <span class="comment">// Length of node name, or undefined of no name</span>
<a name="l00789"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#aa3a49d8ceddb8a8d7edb773a2226b89c">00789</a>         std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#aa3a49d8ceddb8a8d7edb773a2226b89c">m_value_size</a>;           <span class="comment">// Length of node value, or undefined if no value</span>
<a name="l00790"></a><a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">00790</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a>;             <span class="comment">// Pointer to parent node, or 0 if none</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792     };
<a name="l00793"></a>00793 
<a name="l00799"></a>00799     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch = <span class="keywordtype">char</span>&gt;
<a name="l00800"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">00800</a>     <span class="keyword">class </span><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute</a>: <span class="keyword">public</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html">xml_base</a>&lt;Ch&gt;
<a name="l00801"></a>00801     {
<a name="l00802"></a>00802 
<a name="l00803"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#aa7e464ce3fe512598ff8dda47291941f">00803</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;;
<a name="l00804"></a>00804     
<a name="l00805"></a>00805     <span class="keyword">public</span>:
<a name="l00806"></a>00806 
<a name="l00808"></a>00808         <span class="comment">// Construction &amp; destruction</span>
<a name="l00809"></a>00809     
<a name="l00812"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a26be291103917d3e8de110d46dd83816">00812</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a26be291103917d3e8de110d46dd83816">xml_attribute</a>()
<a name="l00813"></a>00813         {
<a name="l00814"></a>00814         }
<a name="l00815"></a>00815 
<a name="l00817"></a>00817         <span class="comment">// Related nodes access</span>
<a name="l00818"></a>00818     
<a name="l00821"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a8b6d31d899e27f01bde35b53d98496ec">00821</a>         <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">xml_document&lt;Ch&gt;</a> *<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a8b6d31d899e27f01bde35b53d98496ec">document</a>()<span class="keyword"> const</span>
<a name="l00822"></a>00822 <span class="keyword">        </span>{
<a name="l00823"></a>00823             <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *node;
<a name="l00824"></a>00824             <span class="keywordflow">if</span> (node = this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>())
<a name="l00825"></a>00825             {
<a name="l00826"></a>00826                 <span class="keywordflow">while</span> (node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>())
<a name="l00827"></a>00827                     node = node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>();
<a name="l00828"></a>00828                 <span class="keywordflow">return</span> node-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>() == <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca4023b6a1c7059fd8fbec2112d5c35424" title="A document node. Name and value are empty.">node_document</a> ? <span class="keyword">static_cast&lt;</span><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">xml_document&lt;Ch&gt;</a> *<span class="keyword">&gt;</span>(node) : 0;
<a name="l00829"></a>00829             }
<a name="l00830"></a>00830             <span class="keywordflow">else</span>
<a name="l00831"></a>00831                 <span class="keywordflow">return</span> 0;
<a name="l00832"></a>00832         }
<a name="l00833"></a>00833 
<a name="l00839"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#ae3547cc30b201fd6d7b98c04dda26f89">00839</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#ae3547cc30b201fd6d7b98c04dda26f89">previous_attribute</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00840"></a>00840 <span class="keyword">        </span>{
<a name="l00841"></a>00841             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00842"></a>00842             {
<a name="l00843"></a>00843                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l00844"></a>00844                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l00845"></a>00845                 <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_prev_attribute; attribute; attribute = attribute-&gt;m_prev_attribute)
<a name="l00846"></a>00846                     <span class="keywordflow">if</span> (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="l00847"></a>00847                         <span class="keywordflow">return</span> attribute;
<a name="l00848"></a>00848                 <span class="keywordflow">return</span> 0;
<a name="l00849"></a>00849             }
<a name="l00850"></a>00850             <span class="keywordflow">else</span>
<a name="l00851"></a>00851                 <span class="keywordflow">return</span> this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> ? m_prev_attribute : 0;
<a name="l00852"></a>00852         }
<a name="l00853"></a>00853 
<a name="l00859"></a><a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a56c08d7c96203286c889a43849328a86">00859</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html#a56c08d7c96203286c889a43849328a86">next_attribute</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00860"></a>00860 <span class="keyword">        </span>{
<a name="l00861"></a>00861             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00862"></a>00862             {
<a name="l00863"></a>00863                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l00864"></a>00864                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l00865"></a>00865                 <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_next_attribute; attribute; attribute = attribute-&gt;m_next_attribute)
<a name="l00866"></a>00866                     <span class="keywordflow">if</span> (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="l00867"></a>00867                         <span class="keywordflow">return</span> attribute;
<a name="l00868"></a>00868                 <span class="keywordflow">return</span> 0;
<a name="l00869"></a>00869             }
<a name="l00870"></a>00870             <span class="keywordflow">else</span>
<a name="l00871"></a>00871                 <span class="keywordflow">return</span> this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> ? m_next_attribute : 0;
<a name="l00872"></a>00872         }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874     <span class="keyword">private</span>:
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *m_prev_attribute;        <span class="comment">// Pointer to previous sibling of attribute, or 0 if none; only valid if parent is non-zero</span>
<a name="l00877"></a>00877         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *m_next_attribute;        <span class="comment">// Pointer to next sibling of attribute, or 0 if none; only valid if parent is non-zero</span>
<a name="l00878"></a>00878     
<a name="l00879"></a>00879     };
<a name="l00880"></a>00880 
<a name="l00882"></a>00882     <span class="comment">// XML node</span>
<a name="l00883"></a>00883 
<a name="l00892"></a>00892     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch = <span class="keywordtype">char</span>&gt;
<a name="l00893"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">00893</a>     <span class="keyword">class </span><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a>: <span class="keyword">public</span> <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html">xml_base</a>&lt;Ch&gt;
<a name="l00894"></a>00894     {
<a name="l00895"></a>00895 
<a name="l00896"></a>00896     <span class="keyword">public</span>:
<a name="l00897"></a>00897 
<a name="l00899"></a>00899         <span class="comment">// Construction &amp; destruction</span>
<a name="l00900"></a>00900     
<a name="l00904"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8bd9019960b90605a45998b661fb1b0e">00904</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8bd9019960b90605a45998b661fb1b0e">xml_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>)
<a name="l00905"></a>00905             : m_type(type)
<a name="l00906"></a>00906             , m_first_node(0)
<a name="l00907"></a>00907             , m_first_attribute(0)
<a name="l00908"></a>00908         {
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910 
<a name="l00912"></a>00912         <span class="comment">// Node data access</span>
<a name="l00913"></a>00913     
<a name="l00916"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">00916</a>         <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>()<span class="keyword"> const</span>
<a name="l00917"></a>00917 <span class="keyword">        </span>{
<a name="l00918"></a>00918             <span class="keywordflow">return</span> m_type;
<a name="l00919"></a>00919         }
<a name="l00920"></a>00920 
<a name="l00922"></a>00922         <span class="comment">// Related nodes access</span>
<a name="l00923"></a>00923     
<a name="l00926"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#adb6ad21a4590cf13d4a6a5036e3cdbbc">00926</a>         <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">xml_document&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#adb6ad21a4590cf13d4a6a5036e3cdbbc">document</a>()<span class="keyword"> const</span>
<a name="l00927"></a>00927 <span class="keyword">        </span>{
<a name="l00928"></a>00928             <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *node = <span class="keyword">const_cast&lt;</span><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);
<a name="l00929"></a>00929             <span class="keywordflow">while</span> (node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>())
<a name="l00930"></a>00930                 node = node-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>();
<a name="l00931"></a>00931             <span class="keywordflow">return</span> node-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>() == <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca4023b6a1c7059fd8fbec2112d5c35424" title="A document node. Name and value are empty.">node_document</a> ? <span class="keyword">static_cast&lt;</span><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">xml_document&lt;Ch&gt;</a> *<span class="keyword">&gt;</span>(node) : 0;
<a name="l00932"></a>00932         }
<a name="l00933"></a>00933 
<a name="l00939"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">00939</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00940"></a>00940 <span class="keyword">        </span>{
<a name="l00941"></a>00941             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00942"></a>00942             {
<a name="l00943"></a>00943                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l00944"></a>00944                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l00945"></a>00945                 <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child = m_first_node; child; child = child-&gt;next_sibling())
<a name="l00946"></a>00946                     <span class="keywordflow">if</span> (internal::compare(child-&gt;name(), child-&gt;name_size(), name, name_size, case_sensitive))
<a name="l00947"></a>00947                         <span class="keywordflow">return</span> child;
<a name="l00948"></a>00948                 <span class="keywordflow">return</span> 0;
<a name="l00949"></a>00949             }
<a name="l00950"></a>00950             <span class="keywordflow">else</span>
<a name="l00951"></a>00951                 <span class="keywordflow">return</span> m_first_node;
<a name="l00952"></a>00952         }
<a name="l00953"></a>00953 
<a name="l00961"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2ace550c18cf10da6303773972d7157f">00961</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2ace550c18cf10da6303773972d7157f">last_node</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00962"></a>00962 <span class="keyword">        </span>{
<a name="l00963"></a>00963             assert(m_first_node);  <span class="comment">// Cannot query for last child if node has no children</span>
<a name="l00964"></a>00964             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00965"></a>00965             {
<a name="l00966"></a>00966                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l00967"></a>00967                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l00968"></a>00968                 <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child = m_last_node; child; child = child-&gt;previous_sibling())
<a name="l00969"></a>00969                     <span class="keywordflow">if</span> (internal::compare(child-&gt;name(), child-&gt;name_size(), name, name_size, case_sensitive))
<a name="l00970"></a>00970                         <span class="keywordflow">return</span> child;
<a name="l00971"></a>00971                 <span class="keywordflow">return</span> 0;
<a name="l00972"></a>00972             }
<a name="l00973"></a>00973             <span class="keywordflow">else</span>
<a name="l00974"></a>00974                 <span class="keywordflow">return</span> m_last_node;
<a name="l00975"></a>00975         }
<a name="l00976"></a>00976 
<a name="l00984"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a001ece4e227eebbd6ad0ec7dacf1c00b">00984</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a001ece4e227eebbd6ad0ec7dacf1c00b">previous_sibling</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l00985"></a>00985 <span class="keyword">        </span>{
<a name="l00986"></a>00986             assert(this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a>);     <span class="comment">// Cannot query for siblings if node has no parent</span>
<a name="l00987"></a>00987             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l00988"></a>00988             {
<a name="l00989"></a>00989                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l00990"></a>00990                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l00991"></a>00991                 <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *sibling = m_prev_sibling; sibling; sibling = sibling-&gt;m_prev_sibling)
<a name="l00992"></a>00992                     <span class="keywordflow">if</span> (internal::compare(sibling-&gt;name(), sibling-&gt;name_size(), name, name_size, case_sensitive))
<a name="l00993"></a>00993                         <span class="keywordflow">return</span> sibling;
<a name="l00994"></a>00994                 <span class="keywordflow">return</span> 0;
<a name="l00995"></a>00995             }
<a name="l00996"></a>00996             <span class="keywordflow">else</span>
<a name="l00997"></a>00997                 <span class="keywordflow">return</span> m_prev_sibling;
<a name="l00998"></a>00998         }
<a name="l00999"></a>00999 
<a name="l01007"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ac59af4dd5f0ec715753e42467dff6aed">01007</a>         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ac59af4dd5f0ec715753e42467dff6aed">next_sibling</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l01008"></a>01008 <span class="keyword">        </span>{
<a name="l01009"></a>01009             assert(this-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a>);     <span class="comment">// Cannot query for siblings if node has no parent</span>
<a name="l01010"></a>01010             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l01011"></a>01011             {
<a name="l01012"></a>01012                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l01013"></a>01013                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l01014"></a>01014                 <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *sibling = m_next_sibling; sibling; sibling = sibling-&gt;m_next_sibling)
<a name="l01015"></a>01015                     <span class="keywordflow">if</span> (internal::compare(sibling-&gt;name(), sibling-&gt;name_size(), name, name_size, case_sensitive))
<a name="l01016"></a>01016                         <span class="keywordflow">return</span> sibling;
<a name="l01017"></a>01017                 <span class="keywordflow">return</span> 0;
<a name="l01018"></a>01018             }
<a name="l01019"></a>01019             <span class="keywordflow">else</span>
<a name="l01020"></a>01020                 <span class="keywordflow">return</span> m_next_sibling;
<a name="l01021"></a>01021         }
<a name="l01022"></a>01022 
<a name="l01028"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">01028</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l01029"></a>01029 <span class="keyword">        </span>{
<a name="l01030"></a>01030             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l01031"></a>01031             {
<a name="l01032"></a>01032                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l01033"></a>01033                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l01034"></a>01034                 <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_first_attribute; attribute; attribute = attribute-&gt;m_next_attribute)
<a name="l01035"></a>01035                     <span class="keywordflow">if</span> (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="l01036"></a>01036                         <span class="keywordflow">return</span> attribute;
<a name="l01037"></a>01037                 <span class="keywordflow">return</span> 0;
<a name="l01038"></a>01038             }
<a name="l01039"></a>01039             <span class="keywordflow">else</span>
<a name="l01040"></a>01040                 <span class="keywordflow">return</span> m_first_attribute;
<a name="l01041"></a>01041         }
<a name="l01042"></a>01042 
<a name="l01048"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a50c03f2db3fa51f27a73d86ec29a49d3">01048</a>         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a50c03f2db3fa51f27a73d86ec29a49d3">last_attribute</a>(<span class="keyword">const</span> Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = 0, std::size_t <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = 0, <span class="keywordtype">bool</span> case_sensitive = <span class="keyword">true</span>)<span class="keyword"> const</span>
<a name="l01049"></a>01049 <span class="keyword">        </span>{
<a name="l01050"></a>01050             <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>)
<a name="l01051"></a>01051             {
<a name="l01052"></a>01052                 <span class="keywordflow">if</span> (<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> == 0)
<a name="l01053"></a>01053                     <a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7e7f98b3d01e1eab8dc1ca69aad9af84">name_size</a> = internal::measure(<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a>);
<a name="l01054"></a>01054                 <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_last_attribute; attribute; attribute = attribute-&gt;m_prev_attribute)
<a name="l01055"></a>01055                     <span class="keywordflow">if</span> (internal::compare(attribute-&gt;name(), attribute-&gt;name_size(), name, name_size, case_sensitive))
<a name="l01056"></a>01056                         <span class="keywordflow">return</span> attribute;
<a name="l01057"></a>01057                 <span class="keywordflow">return</span> 0;
<a name="l01058"></a>01058             }
<a name="l01059"></a>01059             <span class="keywordflow">else</span>
<a name="l01060"></a>01060                 <span class="keywordflow">return</span> m_first_attribute ? m_last_attribute : 0;
<a name="l01061"></a>01061         }
<a name="l01062"></a>01062 
<a name="l01064"></a>01064         <span class="comment">// Node modification</span>
<a name="l01065"></a>01065     
<a name="l01068"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a499bbc9300c1b06821d5c08b24164c68">01068</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>)
<a name="l01069"></a>01069         {
<a name="l01070"></a>01070             m_type = type;
<a name="l01071"></a>01071         }
<a name="l01072"></a>01072 
<a name="l01074"></a>01074         <span class="comment">// Node manipulation</span>
<a name="l01075"></a>01075 
<a name="l01079"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae86e92908c3eab40bbed8216e4f3f3cb">01079</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae86e92908c3eab40bbed8216e4f3f3cb">prepend_node</a>(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child)
<a name="l01080"></a>01080         {
<a name="l01081"></a>01081             assert(child &amp;&amp; !child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() &amp;&amp; child-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>() != node_document);
<a name="l01082"></a>01082             <span class="keywordflow">if</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>())
<a name="l01083"></a>01083             {
<a name="l01084"></a>01084                 child-&gt;m_next_sibling = m_first_node;
<a name="l01085"></a>01085                 m_first_node-&gt;m_prev_sibling = child;
<a name="l01086"></a>01086             }
<a name="l01087"></a>01087             <span class="keywordflow">else</span>
<a name="l01088"></a>01088             {
<a name="l01089"></a>01089                 child-&gt;m_next_sibling = 0;
<a name="l01090"></a>01090                 m_last_node = child;
<a name="l01091"></a>01091             }
<a name="l01092"></a>01092             m_first_node = child;
<a name="l01093"></a>01093             child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01094"></a>01094             child-&gt;m_prev_sibling = 0;
<a name="l01095"></a>01095         }
<a name="l01096"></a>01096 
<a name="l01100"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8696d098ecc9c4d2a646b43e91d58e31">01100</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8696d098ecc9c4d2a646b43e91d58e31">append_node</a>(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child)
<a name="l01101"></a>01101         {
<a name="l01102"></a>01102             assert(child &amp;&amp; !child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() &amp;&amp; child-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>() != node_document);
<a name="l01103"></a>01103             <span class="keywordflow">if</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>())
<a name="l01104"></a>01104             {
<a name="l01105"></a>01105                 child-&gt;m_prev_sibling = m_last_node;
<a name="l01106"></a>01106                 m_last_node-&gt;m_next_sibling = child;
<a name="l01107"></a>01107             }
<a name="l01108"></a>01108             <span class="keywordflow">else</span>
<a name="l01109"></a>01109             {
<a name="l01110"></a>01110                 child-&gt;m_prev_sibling = 0;
<a name="l01111"></a>01111                 m_first_node = child;
<a name="l01112"></a>01112             }
<a name="l01113"></a>01113             m_last_node = child;
<a name="l01114"></a>01114             child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01115"></a>01115             child-&gt;m_next_sibling = 0;
<a name="l01116"></a>01116         }
<a name="l01117"></a>01117 
<a name="l01122"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a666880f42a7e486d78cc45ed51c7c46d">01122</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a666880f42a7e486d78cc45ed51c7c46d">insert_node</a>(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *where, <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child)
<a name="l01123"></a>01123         {
<a name="l01124"></a>01124             assert(!where || where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() == <span class="keyword">this</span>);
<a name="l01125"></a>01125             assert(child &amp;&amp; !child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() &amp;&amp; child-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2c6a4315b98bcfa2e04fed3fa1b22c36">type</a>() != node_document);
<a name="l01126"></a>01126             <span class="keywordflow">if</span> (where == m_first_node)
<a name="l01127"></a>01127                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae86e92908c3eab40bbed8216e4f3f3cb">prepend_node</a>(child);
<a name="l01128"></a>01128             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (where == 0)
<a name="l01129"></a>01129                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8696d098ecc9c4d2a646b43e91d58e31">append_node</a>(child);
<a name="l01130"></a>01130             <span class="keywordflow">else</span>
<a name="l01131"></a>01131             {
<a name="l01132"></a>01132                 child-&gt;m_prev_sibling = where-&gt;m_prev_sibling;
<a name="l01133"></a>01133                 child-&gt;m_next_sibling = where;
<a name="l01134"></a>01134                 where-&gt;m_prev_sibling-&gt;m_next_sibling = child;
<a name="l01135"></a>01135                 where-&gt;m_prev_sibling = child;
<a name="l01136"></a>01136                 child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01137"></a>01137             }
<a name="l01138"></a>01138         }
<a name="l01139"></a>01139 
<a name="l01143"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a62bf7b276cf7a651a3337f5e0a0ef6ac">01143</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a62bf7b276cf7a651a3337f5e0a0ef6ac">remove_first_node</a>()
<a name="l01144"></a>01144         {
<a name="l01145"></a>01145             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>());
<a name="l01146"></a>01146             <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child = m_first_node;
<a name="l01147"></a>01147             m_first_node = child-&gt;m_next_sibling;
<a name="l01148"></a>01148             <span class="keywordflow">if</span> (child-&gt;m_next_sibling)
<a name="l01149"></a>01149                 child-&gt;m_next_sibling-&gt;m_prev_sibling = 0;
<a name="l01150"></a>01150             <span class="keywordflow">else</span>
<a name="l01151"></a>01151                 m_last_node = 0;
<a name="l01152"></a>01152             child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01153"></a>01153         }
<a name="l01154"></a>01154 
<a name="l01158"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a9182512e948ec451a83f116cce7c7674">01158</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a9182512e948ec451a83f116cce7c7674">remove_last_node</a>()
<a name="l01159"></a>01159         {
<a name="l01160"></a>01160             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>());
<a name="l01161"></a>01161             <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *child = m_last_node;
<a name="l01162"></a>01162             <span class="keywordflow">if</span> (child-&gt;m_prev_sibling)
<a name="l01163"></a>01163             {
<a name="l01164"></a>01164                 m_last_node = child-&gt;m_prev_sibling;
<a name="l01165"></a>01165                 child-&gt;m_prev_sibling-&gt;m_next_sibling = 0;
<a name="l01166"></a>01166             }
<a name="l01167"></a>01167             <span class="keywordflow">else</span>
<a name="l01168"></a>01168                 m_first_node = 0;
<a name="l01169"></a>01169             child-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01170"></a>01170         }
<a name="l01171"></a>01171 
<a name="l01173"></a>01173         <span class="comment">// \param where Pointer to child to be removed.</span>
<a name="l01174"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a98289923eb9e8889418a9eb0207ea35c">01174</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a98289923eb9e8889418a9eb0207ea35c" title="Removes specified child from the node.">remove_node</a>(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *where)
<a name="l01175"></a>01175         {
<a name="l01176"></a>01176             assert(where &amp;&amp; where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() == <span class="keyword">this</span>);
<a name="l01177"></a>01177             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>());
<a name="l01178"></a>01178             <span class="keywordflow">if</span> (where == m_first_node)
<a name="l01179"></a>01179                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a62bf7b276cf7a651a3337f5e0a0ef6ac">remove_first_node</a>();
<a name="l01180"></a>01180             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (where == m_last_node)
<a name="l01181"></a>01181                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a9182512e948ec451a83f116cce7c7674">remove_last_node</a>();
<a name="l01182"></a>01182             <span class="keywordflow">else</span>
<a name="l01183"></a>01183             {
<a name="l01184"></a>01184                 where-&gt;m_prev_sibling-&gt;m_next_sibling = where-&gt;m_next_sibling;
<a name="l01185"></a>01185                 where-&gt;m_next_sibling-&gt;m_prev_sibling = where-&gt;m_prev_sibling;
<a name="l01186"></a>01186                 where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01187"></a>01187             }
<a name="l01188"></a>01188         }
<a name="l01189"></a>01189 
<a name="l01191"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a95735358b079ae0adcfbbac69aa1fbc3">01191</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a95735358b079ae0adcfbbac69aa1fbc3" title="Removes all child nodes (but not attributes).">remove_all_nodes</a>()
<a name="l01192"></a>01192         {
<a name="l01193"></a>01193             <span class="keywordflow">for</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *node = <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a2dedeb4e04bb35e06a9a7bddf6ba652d">first_node</a>(); node; node = node-&gt;m_next_sibling)
<a name="l01194"></a>01194                 node-&gt;m_parent = 0;
<a name="l01195"></a>01195             m_first_node = 0;
<a name="l01196"></a>01196         }
<a name="l01197"></a>01197 
<a name="l01200"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8b62ee76489faf8e2d1210869d547684">01200</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8b62ee76489faf8e2d1210869d547684">prepend_attribute</a>(<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute)
<a name="l01201"></a>01201         {
<a name="l01202"></a>01202             assert(attribute &amp;&amp; !attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>());
<a name="l01203"></a>01203             <span class="keywordflow">if</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>())
<a name="l01204"></a>01204             {
<a name="l01205"></a>01205                 attribute-&gt;m_next_attribute = m_first_attribute;
<a name="l01206"></a>01206                 m_first_attribute-&gt;m_prev_attribute = attribute;
<a name="l01207"></a>01207             }
<a name="l01208"></a>01208             <span class="keywordflow">else</span>
<a name="l01209"></a>01209             {
<a name="l01210"></a>01210                 attribute-&gt;m_next_attribute = 0;
<a name="l01211"></a>01211                 m_last_attribute = attribute;
<a name="l01212"></a>01212             }
<a name="l01213"></a>01213             m_first_attribute = attribute;
<a name="l01214"></a>01214             attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01215"></a>01215             attribute-&gt;m_prev_attribute = 0;
<a name="l01216"></a>01216         }
<a name="l01217"></a>01217 
<a name="l01220"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a33ce3386f8c42dd4db658b75cbb6e6c4">01220</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a33ce3386f8c42dd4db658b75cbb6e6c4">append_attribute</a>(<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute)
<a name="l01221"></a>01221         {
<a name="l01222"></a>01222             assert(attribute &amp;&amp; !attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>());
<a name="l01223"></a>01223             <span class="keywordflow">if</span> (<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>())
<a name="l01224"></a>01224             {
<a name="l01225"></a>01225                 attribute-&gt;m_prev_attribute = m_last_attribute;
<a name="l01226"></a>01226                 m_last_attribute-&gt;m_next_attribute = attribute;
<a name="l01227"></a>01227             }
<a name="l01228"></a>01228             <span class="keywordflow">else</span>
<a name="l01229"></a>01229             {
<a name="l01230"></a>01230                 attribute-&gt;m_prev_attribute = 0;
<a name="l01231"></a>01231                 m_first_attribute = attribute;
<a name="l01232"></a>01232             }
<a name="l01233"></a>01233             m_last_attribute = attribute;
<a name="l01234"></a>01234             attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01235"></a>01235             attribute-&gt;m_next_attribute = 0;
<a name="l01236"></a>01236         }
<a name="l01237"></a>01237 
<a name="l01242"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a9fe659cdf4a5b3bbf5e8ffc98db5a84f">01242</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a9fe659cdf4a5b3bbf5e8ffc98db5a84f">insert_attribute</a>(<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *where, <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute)
<a name="l01243"></a>01243         {
<a name="l01244"></a>01244             assert(!where || where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() == <span class="keyword">this</span>);
<a name="l01245"></a>01245             assert(attribute &amp;&amp; !attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>());
<a name="l01246"></a>01246             <span class="keywordflow">if</span> (where == m_first_attribute)
<a name="l01247"></a>01247                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8b62ee76489faf8e2d1210869d547684">prepend_attribute</a>(attribute);
<a name="l01248"></a>01248             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (where == 0)
<a name="l01249"></a>01249                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a33ce3386f8c42dd4db658b75cbb6e6c4">append_attribute</a>(attribute);
<a name="l01250"></a>01250             <span class="keywordflow">else</span>
<a name="l01251"></a>01251             {
<a name="l01252"></a>01252                 attribute-&gt;m_prev_attribute = where-&gt;m_prev_attribute;
<a name="l01253"></a>01253                 attribute-&gt;m_next_attribute = where;
<a name="l01254"></a>01254                 where-&gt;m_prev_attribute-&gt;m_next_attribute = attribute;
<a name="l01255"></a>01255                 where-&gt;m_prev_attribute = attribute;
<a name="l01256"></a>01256                 attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = <span class="keyword">this</span>;
<a name="l01257"></a>01257             }
<a name="l01258"></a>01258         }
<a name="l01259"></a>01259 
<a name="l01263"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa95192d2a165cca16c551ed2a2a06aec">01263</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa95192d2a165cca16c551ed2a2a06aec">remove_first_attribute</a>()
<a name="l01264"></a>01264         {
<a name="l01265"></a>01265             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>());
<a name="l01266"></a>01266             <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_first_attribute;
<a name="l01267"></a>01267             <span class="keywordflow">if</span> (attribute-&gt;m_next_attribute)
<a name="l01268"></a>01268             {
<a name="l01269"></a>01269                 attribute-&gt;m_next_attribute-&gt;m_prev_attribute = 0;
<a name="l01270"></a>01270             }
<a name="l01271"></a>01271             <span class="keywordflow">else</span>
<a name="l01272"></a>01272                 m_last_attribute = 0;
<a name="l01273"></a>01273             attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01274"></a>01274             m_first_attribute = attribute-&gt;m_next_attribute;
<a name="l01275"></a>01275         }
<a name="l01276"></a>01276 
<a name="l01280"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a1781a2cbedc9a51d609ad5b528125635">01280</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a1781a2cbedc9a51d609ad5b528125635">remove_last_attribute</a>()
<a name="l01281"></a>01281         {
<a name="l01282"></a>01282             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>());
<a name="l01283"></a>01283             <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = m_last_attribute;
<a name="l01284"></a>01284             <span class="keywordflow">if</span> (attribute-&gt;m_prev_attribute)
<a name="l01285"></a>01285             {
<a name="l01286"></a>01286                 attribute-&gt;m_prev_attribute-&gt;m_next_attribute = 0;
<a name="l01287"></a>01287                 m_last_attribute = attribute-&gt;m_prev_attribute;
<a name="l01288"></a>01288             }
<a name="l01289"></a>01289             <span class="keywordflow">else</span>
<a name="l01290"></a>01290                 m_first_attribute = 0;
<a name="l01291"></a>01291             attribute-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01292"></a>01292         }
<a name="l01293"></a>01293 
<a name="l01296"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a6f97b1b4f46a94a4587915df3c0c6b57">01296</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a6f97b1b4f46a94a4587915df3c0c6b57">remove_attribute</a>(<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *where)
<a name="l01297"></a>01297         {
<a name="l01298"></a>01298             assert(<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>() &amp;&amp; where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a7f31ae930f93852830234db1ae59c4c4">parent</a>() == <span class="keyword">this</span>);
<a name="l01299"></a>01299             <span class="keywordflow">if</span> (where == m_first_attribute)
<a name="l01300"></a>01300                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa95192d2a165cca16c551ed2a2a06aec">remove_first_attribute</a>();
<a name="l01301"></a>01301             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (where == m_last_attribute)
<a name="l01302"></a>01302                 <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a1781a2cbedc9a51d609ad5b528125635">remove_last_attribute</a>();
<a name="l01303"></a>01303             <span class="keywordflow">else</span>
<a name="l01304"></a>01304             {
<a name="l01305"></a>01305                 where-&gt;m_prev_attribute-&gt;m_next_attribute = where-&gt;m_next_attribute;
<a name="l01306"></a>01306                 where-&gt;m_next_attribute-&gt;m_prev_attribute = where-&gt;m_prev_attribute;
<a name="l01307"></a>01307                 where-&gt;<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a90d5f660f078f66563fd7b2d8387ccb0">m_parent</a> = 0;
<a name="l01308"></a>01308             }
<a name="l01309"></a>01309         }
<a name="l01310"></a>01310 
<a name="l01312"></a><a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa8d5d9484aa1eb5ff1841a073c84c1aa">01312</a>         <span class="keywordtype">void</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa8d5d9484aa1eb5ff1841a073c84c1aa" title="Removes all attributes of node.">remove_all_attributes</a>()
<a name="l01313"></a>01313         {
<a name="l01314"></a>01314             <span class="keywordflow">for</span> (<a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *attribute = <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#ae426802be58114ffc41bf30ac6b8c37d">first_attribute</a>(); attribute; attribute = attribute-&gt;m_next_attribute)
<a name="l01315"></a>01315                 attribute-&gt;m_parent = 0;
<a name="l01316"></a>01316             m_first_attribute = 0;
<a name="l01317"></a>01317         }
<a name="l01318"></a>01318         
<a name="l01319"></a>01319     <span class="keyword">private</span>:
<a name="l01320"></a>01320 
<a name="l01322"></a>01322         <span class="comment">// Restrictions</span>
<a name="l01323"></a>01323 
<a name="l01324"></a>01324         <span class="comment">// No copying</span>
<a name="l01325"></a>01325         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8bd9019960b90605a45998b661fb1b0e">xml_node</a>(<span class="keyword">const</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a> &amp;);
<a name="l01326"></a>01326         <span class="keywordtype">void</span> operator =(<span class="keyword">const</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a> &amp;);
<a name="l01327"></a>01327     
<a name="l01329"></a>01329         <span class="comment">// Data members</span>
<a name="l01330"></a>01330     
<a name="l01331"></a>01331         <span class="comment">// Note that some of the pointers below have UNDEFINED values if certain other pointers are 0.</span>
<a name="l01332"></a>01332         <span class="comment">// This is required for maximum performance, as it allows the parser to omit initialization of </span>
<a name="l01333"></a>01333         <span class="comment">// unneded/redundant values.</span>
<a name="l01334"></a>01334         <span class="comment">//</span>
<a name="l01335"></a>01335         <span class="comment">// The rules are as follows:</span>
<a name="l01336"></a>01336         <span class="comment">// 1. first_node and first_attribute contain valid pointers, or 0 if node has no children/attributes respectively</span>
<a name="l01337"></a>01337         <span class="comment">// 2. last_node and last_attribute are valid only if node has at least one child/attribute respectively, otherwise they contain garbage</span>
<a name="l01338"></a>01338         <span class="comment">// 3. prev_sibling and next_sibling are valid only if node has a parent, otherwise they contain garbage</span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340         <a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7c">node_type</a> m_type;                       <span class="comment">// Type of node; always valid</span>
<a name="l01341"></a>01341         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *m_first_node;             <span class="comment">// Pointer to first child node, or 0 if none; always valid</span>
<a name="l01342"></a>01342         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *m_last_node;              <span class="comment">// Pointer to last child node, or 0 if none; this value is only valid if m_first_node is non-zero</span>
<a name="l01343"></a>01343         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *m_first_attribute;   <span class="comment">// Pointer to first attribute of node, or 0 if none; always valid</span>
<a name="l01344"></a>01344         <a class="code" href="../../d9/db7/classrapidxml_1_1xml__attribute.html">xml_attribute&lt;Ch&gt;</a> *m_last_attribute;    <span class="comment">// Pointer to last attribute of node, or 0 if none; this value is only valid if m_first_attribute is non-zero</span>
<a name="l01345"></a>01345         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *m_prev_sibling;           <span class="comment">// Pointer to previous sibling of node, or 0 if none; this value is only valid if m_parent is non-zero</span>
<a name="l01346"></a>01346         <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *m_next_sibling;           <span class="comment">// Pointer to next sibling of node, or 0 if none; this value is only valid if m_parent is non-zero</span>
<a name="l01347"></a>01347 
<a name="l01348"></a>01348     };
<a name="l01349"></a>01349 
<a name="l01351"></a>01351     <span class="comment">// XML document</span>
<a name="l01352"></a>01352     
<a name="l01360"></a>01360     <span class="keyword">template</span>&lt;<span class="keyword">class</span> Ch = <span class="keywordtype">char</span>&gt;
<a name="l01361"></a><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">01361</a>     <span class="keyword">class </span><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html">xml_document</a>: <span class="keyword">public</span> <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;, <span class="keyword">public</span> <a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html">memory_pool</a>&lt;Ch&gt;
<a name="l01362"></a>01362     {
<a name="l01363"></a>01363     
<a name="l01364"></a>01364     <span class="keyword">public</span>:
<a name="l01365"></a>01365 
<a name="l01367"></a><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#aae8841b15085ba8f32ff46587ace28f5">01367</a>         <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#aae8841b15085ba8f32ff46587ace28f5" title="Constructs empty XML document.">xml_document</a>()
<a name="l01368"></a>01368             : <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node</a>&lt;Ch&gt;(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca4023b6a1c7059fd8fbec2112d5c35424" title="A document node. Name and value are empty.">node_document</a>)
<a name="l01369"></a>01369         {
<a name="l01370"></a>01370         }
<a name="l01371"></a>01371 
<a name="l01383"></a>01383         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01384"></a><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#ad510b0c5fd8bf0180a55ffb2476e59e4">01384</a>         <span class="keywordtype">void</span> <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#ad510b0c5fd8bf0180a55ffb2476e59e4">parse</a>(Ch *text)
<a name="l01385"></a>01385         {
<a name="l01386"></a>01386             assert(text);
<a name="l01387"></a>01387             
<a name="l01388"></a>01388             <span class="comment">// Remove current contents</span>
<a name="l01389"></a>01389             this-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a95735358b079ae0adcfbbac69aa1fbc3" title="Removes all child nodes (but not attributes).">remove_all_nodes</a>();
<a name="l01390"></a>01390             this-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa8d5d9484aa1eb5ff1841a073c84c1aa" title="Removes all attributes of node.">remove_all_attributes</a>();
<a name="l01391"></a>01391             
<a name="l01392"></a>01392             <span class="comment">// Parse BOM, if any</span>
<a name="l01393"></a>01393             parse_bom&lt;Flags&gt;(text);
<a name="l01394"></a>01394             
<a name="l01395"></a>01395             <span class="comment">// Parse children</span>
<a name="l01396"></a>01396             <span class="keywordflow">while</span> (1)
<a name="l01397"></a>01397             {
<a name="l01398"></a>01398                 <span class="comment">// Skip whitespace before node</span>
<a name="l01399"></a>01399                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l01400"></a>01400                 <span class="keywordflow">if</span> (*text == 0)
<a name="l01401"></a>01401                     <span class="keywordflow">break</span>;
<a name="l01402"></a>01402 
<a name="l01403"></a>01403                 <span class="comment">// Parse and append new child</span>
<a name="l01404"></a>01404                 <span class="keywordflow">if</span> (*text == Ch(<span class="charliteral">&#39;&lt;&#39;</span>))
<a name="l01405"></a>01405                 {
<a name="l01406"></a>01406                     ++text;     <span class="comment">// Skip &#39;&lt;&#39;</span>
<a name="l01407"></a>01407                     <a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html">xml_node&lt;Ch&gt;</a> *node;
<a name="l01408"></a>01408                     <span class="keywordflow">if</span> ((node = parse_node&lt;Flags&gt;(text)))
<a name="l01409"></a>01409                         this-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a8696d098ecc9c4d2a646b43e91d58e31">append_node</a>(node);
<a name="l01410"></a>01410                 }
<a name="l01411"></a>01411                 <span class="keywordflow">else</span>
<a name="l01412"></a>01412                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &lt;&quot;</span>, text);
<a name="l01413"></a>01413             }
<a name="l01414"></a>01414 
<a name="l01415"></a>01415         }
<a name="l01416"></a>01416 
<a name="l01419"></a><a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#a826929ff54242532198701f19ff5f83f">01419</a>         <span class="keywordtype">void</span> <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#a826929ff54242532198701f19ff5f83f">clear</a>()
<a name="l01420"></a>01420         {
<a name="l01421"></a>01421             this-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#a95735358b079ae0adcfbbac69aa1fbc3" title="Removes all child nodes (but not attributes).">remove_all_nodes</a>();
<a name="l01422"></a>01422             this-&gt;<a class="code" href="../../de/d82/classrapidxml_1_1xml__node.html#aa8d5d9484aa1eb5ff1841a073c84c1aa" title="Removes all attributes of node.">remove_all_attributes</a>();
<a name="l01423"></a>01423             <a class="code" href="../../db/d68/classrapidxml_1_1xml__document.html#a826929ff54242532198701f19ff5f83f">memory_pool&lt;Ch&gt;::clear</a>();
<a name="l01424"></a>01424         }
<a name="l01425"></a>01425         
<a name="l01426"></a>01426     <span class="keyword">private</span>:
<a name="l01427"></a>01427 
<a name="l01429"></a>01429         <span class="comment">// Internal character utility functions</span>
<a name="l01430"></a>01430         
<a name="l01431"></a>01431         <span class="comment">// Detect whitespace character</span>
<a name="l01432"></a>01432         <span class="keyword">struct </span>whitespace_pred
<a name="l01433"></a>01433         {
<a name="l01434"></a>01434             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01435"></a>01435             {
<a name="l01436"></a>01436                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_whitespace[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01437"></a>01437             }
<a name="l01438"></a>01438         };
<a name="l01439"></a>01439 
<a name="l01440"></a>01440         <span class="comment">// Detect node name character</span>
<a name="l01441"></a>01441         <span class="keyword">struct </span>node_name_pred
<a name="l01442"></a>01442         {
<a name="l01443"></a>01443             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01444"></a>01444             {
<a name="l01445"></a>01445                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_node_name[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01446"></a>01446             }
<a name="l01447"></a>01447         };
<a name="l01448"></a>01448 
<a name="l01449"></a>01449         <span class="comment">// Detect attribute name character</span>
<a name="l01450"></a>01450         <span class="keyword">struct </span>attribute_name_pred
<a name="l01451"></a>01451         {
<a name="l01452"></a>01452             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01453"></a>01453             {
<a name="l01454"></a>01454                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_attribute_name[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01455"></a>01455             }
<a name="l01456"></a>01456         };
<a name="l01457"></a>01457 
<a name="l01458"></a>01458         <span class="comment">// Detect text character (PCDATA)</span>
<a name="l01459"></a>01459         <span class="keyword">struct </span>text_pred
<a name="l01460"></a>01460         {
<a name="l01461"></a>01461             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01462"></a>01462             {
<a name="l01463"></a>01463                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_text[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01464"></a>01464             }
<a name="l01465"></a>01465         };
<a name="l01466"></a>01466 
<a name="l01467"></a>01467         <span class="comment">// Detect text character (PCDATA) that does not require processing</span>
<a name="l01468"></a>01468         <span class="keyword">struct </span>text_pure_no_ws_pred
<a name="l01469"></a>01469         {
<a name="l01470"></a>01470             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01471"></a>01471             {
<a name="l01472"></a>01472                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_text_pure_no_ws[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01473"></a>01473             }
<a name="l01474"></a>01474         };
<a name="l01475"></a>01475 
<a name="l01476"></a>01476         <span class="comment">// Detect text character (PCDATA) that does not require processing</span>
<a name="l01477"></a>01477         <span class="keyword">struct </span>text_pure_with_ws_pred
<a name="l01478"></a>01478         {
<a name="l01479"></a>01479             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01480"></a>01480             {
<a name="l01481"></a>01481                 <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_text_pure_with_ws[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01482"></a>01482             }
<a name="l01483"></a>01483         };
<a name="l01484"></a>01484 
<a name="l01485"></a>01485         <span class="comment">// Detect attribute value character</span>
<a name="l01486"></a>01486         <span class="keyword">template</span>&lt;Ch Quote&gt;
<a name="l01487"></a>01487         <span class="keyword">struct </span>attribute_value_pred
<a name="l01488"></a>01488         {
<a name="l01489"></a>01489             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01490"></a>01490             {
<a name="l01491"></a>01491                 <span class="keywordflow">if</span> (Quote == Ch(<span class="charliteral">&#39;\&#39;&#39;</span>))
<a name="l01492"></a>01492                     <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_attribute_data_1[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01493"></a>01493                 <span class="keywordflow">if</span> (Quote == Ch(<span class="charliteral">&#39;\&quot;&#39;</span>))
<a name="l01494"></a>01494                     <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_attribute_data_2[static_cast&lt;unsigned char&gt;(ch)];
<a name="l01495"></a>01495                 <span class="keywordflow">return</span> 0;       <span class="comment">// Should never be executed, to avoid warnings on Comeau</span>
<a name="l01496"></a>01496             }
<a name="l01497"></a>01497         };
<a name="l01498"></a>01498 
<a name="l01499"></a>01499         <span class="comment">// Detect attribute value character</span>
<a name="l01500"></a>01500         <span class="keyword">template</span>&lt;Ch Quote&gt;
<a name="l01501"></a>01501         <span class="keyword">struct </span>attribute_value_pure_pred
<a name="l01502"></a>01502         {
<a name="l01503"></a>01503             <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> test(Ch ch)
<a name="l01504"></a>01504             {
<a name="l01505"></a>01505                 <span class="keywordflow">if</span> (Quote == Ch(<span class="charliteral">&#39;\&#39;&#39;</span>))
<a name="l01506"></a>01506                     <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_attribute_data_1_pure[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(ch)];
<a name="l01507"></a>01507                 <span class="keywordflow">if</span> (Quote == Ch(<span class="charliteral">&#39;\&quot;&#39;</span>))
<a name="l01508"></a>01508                     <span class="keywordflow">return</span> internal::lookup_tables&lt;0&gt;::lookup_attribute_data_2_pure[static_cast&lt;unsigned char&gt;(ch)];
<a name="l01509"></a>01509                 <span class="keywordflow">return</span> 0;       <span class="comment">// Should never be executed, to avoid warnings on Comeau</span>
<a name="l01510"></a>01510             }
<a name="l01511"></a>01511         };
<a name="l01512"></a>01512 
<a name="l01513"></a>01513         <span class="comment">// Insert coded character, using UTF8 or 8-bit ASCII</span>
<a name="l01514"></a>01514         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01515"></a>01515         <span class="keyword">static</span> <span class="keywordtype">void</span> insert_coded_character(Ch *&amp;text, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code)
<a name="l01516"></a>01516         {
<a name="l01517"></a>01517             <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a22d4aefaceb00d7afabfef7107b108da">parse_no_utf8</a>)
<a name="l01518"></a>01518             {
<a name="l01519"></a>01519                 <span class="comment">// Insert 8-bit ASCII character</span>
<a name="l01520"></a>01520                 <span class="comment">// Todo: possibly verify that code is less than 256 and use replacement char otherwise?</span>
<a name="l01521"></a>01521                 text[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(code);
<a name="l01522"></a>01522                 text += 1;
<a name="l01523"></a>01523             }
<a name="l01524"></a>01524             <span class="keywordflow">else</span>
<a name="l01525"></a>01525             {
<a name="l01526"></a>01526                 <span class="comment">// Insert UTF8 sequence</span>
<a name="l01527"></a>01527                 <span class="keywordflow">if</span> (code &lt; 0x80)    <span class="comment">// 1 byte sequence</span>
<a name="l01528"></a>01528                 {
<a name="l01529"></a>01529                     text[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(code);
<a name="l01530"></a>01530                     text += 1;
<a name="l01531"></a>01531                 }
<a name="l01532"></a>01532                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &lt; 0x800)  <span class="comment">// 2 byte sequence</span>
<a name="l01533"></a>01533                 {
<a name="l01534"></a>01534                     text[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01535"></a>01535                     text[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(code | 0xC0);
<a name="l01536"></a>01536                     text += 2;
<a name="l01537"></a>01537                 }
<a name="l01538"></a>01538                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &lt; 0x10000)    <span class="comment">// 3 byte sequence</span>
<a name="l01539"></a>01539                 {
<a name="l01540"></a>01540                     text[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01541"></a>01541                     text[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01542"></a>01542                     text[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(code | 0xE0);
<a name="l01543"></a>01543                     text += 3;
<a name="l01544"></a>01544                 }
<a name="l01545"></a>01545                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (code &lt; 0x110000)   <span class="comment">// 4 byte sequence</span>
<a name="l01546"></a>01546                 {
<a name="l01547"></a>01547                     text[3] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01548"></a>01548                     text[2] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01549"></a>01549                     text[1] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>((code | 0x80) &amp; 0xBF); code &gt;&gt;= 6;
<a name="l01550"></a>01550                     text[0] = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(code | 0xF0);
<a name="l01551"></a>01551                     text += 4;
<a name="l01552"></a>01552                 }
<a name="l01553"></a>01553                 <span class="keywordflow">else</span>    <span class="comment">// Invalid, only codes up to 0x10FFFF are allowed in Unicode</span>
<a name="l01554"></a>01554                 {
<a name="l01555"></a>01555                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;invalid numeric character entity&quot;</span>, text);
<a name="l01556"></a>01556                 }
<a name="l01557"></a>01557             }
<a name="l01558"></a>01558         }
<a name="l01559"></a>01559 
<a name="l01560"></a>01560         <span class="comment">// Skip characters until predicate evaluates to true</span>
<a name="l01561"></a>01561         <span class="keyword">template</span>&lt;<span class="keyword">class</span> StopPred, <span class="keywordtype">int</span> Flags&gt;
<a name="l01562"></a>01562         <span class="keyword">static</span> <span class="keywordtype">void</span> skip(Ch *&amp;text)
<a name="l01563"></a>01563         {
<a name="l01564"></a>01564             Ch *tmp = text;
<a name="l01565"></a>01565             <span class="keywordflow">while</span> (StopPred::test(*tmp))
<a name="l01566"></a>01566                 ++tmp;
<a name="l01567"></a>01567             text = tmp;
<a name="l01568"></a>01568         }
<a name="l01569"></a>01569 
<a name="l01570"></a>01570         <span class="comment">// Skip characters until predicate evaluates to true while doing the following:</span>
<a name="l01571"></a>01571         <span class="comment">// - replacing XML character entity references with proper characters (&amp;apos; &amp;amp; &amp;quot; &amp;lt; &amp;gt; &amp;#...;)</span>
<a name="l01572"></a>01572         <span class="comment">// - condensing whitespace sequences to single space character</span>
<a name="l01573"></a>01573         <span class="keyword">template</span>&lt;<span class="keyword">class</span> StopPred, <span class="keyword">class</span> StopPredPure, <span class="keywordtype">int</span> Flags&gt;
<a name="l01574"></a>01574         <span class="keyword">static</span> Ch *skip_and_expand_character_refs(Ch *&amp;text)
<a name="l01575"></a>01575         {
<a name="l01576"></a>01576             <span class="comment">// If entity translation, whitespace condense and whitespace trimming is disabled, use plain skip</span>
<a name="l01577"></a>01577             <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a89113c103ffaf77615d1aa330c8dcca8">parse_no_entity_translation</a> &amp;&amp; 
<a name="l01578"></a>01578                 !(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a31f33885defb5176a7d99e524c35d386">parse_normalize_whitespace</a>) &amp;&amp;
<a name="l01579"></a>01579                 !(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a61912424b47db5038e726d4e1c22417f">parse_trim_whitespace</a>))
<a name="l01580"></a>01580             {
<a name="l01581"></a>01581                 skip&lt;StopPred, Flags&gt;(text);
<a name="l01582"></a>01582                 <span class="keywordflow">return</span> text;
<a name="l01583"></a>01583             }
<a name="l01584"></a>01584             
<a name="l01585"></a>01585             <span class="comment">// Use simple skip until first modification is detected</span>
<a name="l01586"></a>01586             skip&lt;StopPredPure, Flags&gt;(text);
<a name="l01587"></a>01587 
<a name="l01588"></a>01588             <span class="comment">// Use translation skip</span>
<a name="l01589"></a>01589             Ch *src = text;
<a name="l01590"></a>01590             Ch *dest = src;
<a name="l01591"></a>01591             <span class="keywordflow">while</span> (StopPred::test(*src))
<a name="l01592"></a>01592             {
<a name="l01593"></a>01593                 <span class="comment">// If entity translation is enabled    </span>
<a name="l01594"></a>01594                 <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a89113c103ffaf77615d1aa330c8dcca8">parse_no_entity_translation</a>))
<a name="l01595"></a>01595                 {
<a name="l01596"></a>01596                     <span class="comment">// Test if replacement is needed</span>
<a name="l01597"></a>01597                     <span class="keywordflow">if</span> (src[0] == Ch(<span class="charliteral">&#39;&amp;&#39;</span>))
<a name="l01598"></a>01598                     {
<a name="l01599"></a>01599                         <span class="keywordflow">switch</span> (src[1])
<a name="l01600"></a>01600                         {
<a name="l01601"></a>01601 
<a name="l01602"></a>01602                         <span class="comment">// &amp;amp; &amp;apos;</span>
<a name="l01603"></a>01603                         <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;a&#39;</span>): 
<a name="l01604"></a>01604                             if (src[2] == Ch(<span class="stringliteral">&#39;m&#39;</span>) &amp;&amp; src[3] == Ch(<span class="stringliteral">&#39;p&#39;</span>) &amp;&amp; src[4] == Ch(<span class="stringliteral">&#39;;&#39;</span>))
<a name="l01605"></a>01605                             {
<a name="l01606"></a>01606                                 *dest = Ch(<span class="charliteral">&#39;&amp;&#39;</span>);
<a name="l01607"></a>01607                                 ++dest;
<a name="l01608"></a>01608                                 src += 5;
<a name="l01609"></a>01609                                 <span class="keywordflow">continue</span>;
<a name="l01610"></a>01610                             }
<a name="l01611"></a>01611                             <span class="keywordflow">if</span> (src[2] == Ch(<span class="charliteral">&#39;p&#39;</span>) &amp;&amp; src[3] == Ch(<span class="charliteral">&#39;o&#39;</span>) &amp;&amp; src[4] == Ch(<span class="charliteral">&#39;s&#39;</span>) &amp;&amp; src[5] == Ch(<span class="charliteral">&#39;;&#39;</span>))
<a name="l01612"></a>01612                             {
<a name="l01613"></a>01613                                 *dest = Ch(<span class="charliteral">&#39;\&#39;&#39;</span>);
<a name="l01614"></a>01614                                 ++dest;
<a name="l01615"></a>01615                                 src += 6;
<a name="l01616"></a>01616                                 <span class="keywordflow">continue</span>;
<a name="l01617"></a>01617                             }
<a name="l01618"></a>01618                             <span class="keywordflow">break</span>;
<a name="l01619"></a>01619 
<a name="l01620"></a>01620                         <span class="comment">// &amp;quot;</span>
<a name="l01621"></a>01621                         <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;q&#39;</span>): 
<a name="l01622"></a>01622                             if (src[2] == Ch(<span class="stringliteral">&#39;u&#39;</span>) &amp;&amp; src[3] == Ch(<span class="stringliteral">&#39;o&#39;</span>) &amp;&amp; src[4] == Ch(<span class="stringliteral">&#39;t&#39;</span>) &amp;&amp; src[5] == Ch(<span class="stringliteral">&#39;;&#39;</span>))
<a name="l01623"></a>01623                             {
<a name="l01624"></a>01624                                 *dest = Ch(<span class="charliteral">&#39;&quot;&#39;</span>);
<a name="l01625"></a>01625                                 ++dest;
<a name="l01626"></a>01626                                 src += 6;
<a name="l01627"></a>01627                                 <span class="keywordflow">continue</span>;
<a name="l01628"></a>01628                             }
<a name="l01629"></a>01629                             <span class="keywordflow">break</span>;
<a name="l01630"></a>01630 
<a name="l01631"></a>01631                         <span class="comment">// &amp;gt;</span>
<a name="l01632"></a>01632                         <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;g&#39;</span>): 
<a name="l01633"></a>01633                             if (src[2] == Ch(<span class="stringliteral">&#39;t&#39;</span>) &amp;&amp; src[3] == Ch(<span class="stringliteral">&#39;;&#39;</span>))
<a name="l01634"></a>01634                             {
<a name="l01635"></a>01635                                 *dest = Ch(<span class="charliteral">&#39;&gt;&#39;</span>);
<a name="l01636"></a>01636                                 ++dest;
<a name="l01637"></a>01637                                 src += 4;
<a name="l01638"></a>01638                                 <span class="keywordflow">continue</span>;
<a name="l01639"></a>01639                             }
<a name="l01640"></a>01640                             <span class="keywordflow">break</span>;
<a name="l01641"></a>01641 
<a name="l01642"></a>01642                         <span class="comment">// &amp;lt;</span>
<a name="l01643"></a>01643                         <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;l&#39;</span>): 
<a name="l01644"></a>01644                             if (src[2] == Ch(<span class="stringliteral">&#39;t&#39;</span>) &amp;&amp; src[3] == Ch(<span class="stringliteral">&#39;;&#39;</span>))
<a name="l01645"></a>01645                             {
<a name="l01646"></a>01646                                 *dest = Ch(<span class="charliteral">&#39;&lt;&#39;</span>);
<a name="l01647"></a>01647                                 ++dest;
<a name="l01648"></a>01648                                 src += 4;
<a name="l01649"></a>01649                                 <span class="keywordflow">continue</span>;
<a name="l01650"></a>01650                             }
<a name="l01651"></a>01651                             <span class="keywordflow">break</span>;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653                         <span class="comment">// &amp;#...; - assumes ASCII</span>
<a name="l01654"></a>01654                         <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;#&#39;</span>): 
<a name="l01655"></a>01655                             if (src[2] == Ch(<span class="stringliteral">&#39;x&#39;</span>))
<a name="l01656"></a>01656                             {
<a name="l01657"></a>01657                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = 0;
<a name="l01658"></a>01658                                 src += 3;   <span class="comment">// Skip &amp;#x</span>
<a name="l01659"></a>01659                                 <span class="keywordflow">while</span> (1)
<a name="l01660"></a>01660                                 {
<a name="l01661"></a>01661                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> digit = internal::lookup_tables&lt;0&gt;::lookup_digits[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(*src)];
<a name="l01662"></a>01662                                     <span class="keywordflow">if</span> (digit == 0xFF)
<a name="l01663"></a>01663                                         <span class="keywordflow">break</span>;
<a name="l01664"></a>01664                                     code = code * 16 + digit;
<a name="l01665"></a>01665                                     ++src;
<a name="l01666"></a>01666                                 }
<a name="l01667"></a>01667                                 insert_coded_character&lt;Flags&gt;(dest, code);    <span class="comment">// Put character in output</span>
<a name="l01668"></a>01668                             }
<a name="l01669"></a>01669                             <span class="keywordflow">else</span>
<a name="l01670"></a>01670                             {
<a name="l01671"></a>01671                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> code = 0;
<a name="l01672"></a>01672                                 src += 2;   <span class="comment">// Skip &amp;#</span>
<a name="l01673"></a>01673                                 <span class="keywordflow">while</span> (1)
<a name="l01674"></a>01674                                 {
<a name="l01675"></a>01675                                     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> digit = internal::lookup_tables&lt;0&gt;::lookup_digits[<span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span><span class="keyword">&gt;</span>(*src)];
<a name="l01676"></a>01676                                     <span class="keywordflow">if</span> (digit == 0xFF)
<a name="l01677"></a>01677                                         <span class="keywordflow">break</span>;
<a name="l01678"></a>01678                                     code = code * 10 + digit;
<a name="l01679"></a>01679                                     ++src;
<a name="l01680"></a>01680                                 }
<a name="l01681"></a>01681                                 insert_coded_character&lt;Flags&gt;(dest, code);    <span class="comment">// Put character in output</span>
<a name="l01682"></a>01682                             }
<a name="l01683"></a>01683                             <span class="keywordflow">if</span> (*src == Ch(<span class="charliteral">&#39;;&#39;</span>))
<a name="l01684"></a>01684                                 ++src;
<a name="l01685"></a>01685                             <span class="keywordflow">else</span>
<a name="l01686"></a>01686                                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected ;&quot;</span>, src);
<a name="l01687"></a>01687                             <span class="keywordflow">continue</span>;
<a name="l01688"></a>01688 
<a name="l01689"></a>01689                         <span class="comment">// Something else</span>
<a name="l01690"></a>01690                         <span class="keywordflow">default</span>:
<a name="l01691"></a>01691                             <span class="comment">// Ignore, just copy &#39;&amp;&#39; verbatim</span>
<a name="l01692"></a>01692                             <span class="keywordflow">break</span>;
<a name="l01693"></a>01693 
<a name="l01694"></a>01694                         }
<a name="l01695"></a>01695                     }
<a name="l01696"></a>01696                 }
<a name="l01697"></a>01697                 
<a name="l01698"></a>01698                 <span class="comment">// If whitespace condensing is enabled</span>
<a name="l01699"></a>01699                 <span class="keywordflow">if</span> (Flags &amp; parse_normalize_whitespace)
<a name="l01700"></a>01700                 {
<a name="l01701"></a>01701                     <span class="comment">// Test if condensing is needed                 </span>
<a name="l01702"></a>01702                     <span class="keywordflow">if</span> (whitespace_pred::test(*src))
<a name="l01703"></a>01703                     {
<a name="l01704"></a>01704                         *dest = Ch(<span class="charliteral">&#39; &#39;</span>); ++dest;    <span class="comment">// Put single space in dest</span>
<a name="l01705"></a>01705                         ++src;                      <span class="comment">// Skip first whitespace char</span>
<a name="l01706"></a>01706                         <span class="comment">// Skip remaining whitespace chars</span>
<a name="l01707"></a>01707                         <span class="keywordflow">while</span> (whitespace_pred::test(*src))
<a name="l01708"></a>01708                             ++src;
<a name="l01709"></a>01709                         <span class="keywordflow">continue</span>;
<a name="l01710"></a>01710                     }
<a name="l01711"></a>01711                 }
<a name="l01712"></a>01712 
<a name="l01713"></a>01713                 <span class="comment">// No replacement, only copy character</span>
<a name="l01714"></a>01714                 *dest++ = *src++;
<a name="l01715"></a>01715 
<a name="l01716"></a>01716             }
<a name="l01717"></a>01717 
<a name="l01718"></a>01718             <span class="comment">// Return new end</span>
<a name="l01719"></a>01719             text = src;
<a name="l01720"></a>01720             <span class="keywordflow">return</span> dest;
<a name="l01721"></a>01721 
<a name="l01722"></a>01722         }
<a name="l01723"></a>01723 
<a name="l01725"></a>01725         <span class="comment">// Internal parsing functions</span>
<a name="l01726"></a>01726         
<a name="l01727"></a>01727         <span class="comment">// Parse BOM, if any</span>
<a name="l01728"></a>01728         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01729"></a>01729         <span class="keywordtype">void</span> parse_bom(Ch *&amp;text)
<a name="l01730"></a>01730         {
<a name="l01731"></a>01731             <span class="comment">// UTF-8?</span>
<a name="l01732"></a>01732             <span class="keywordflow">if</span> (static_cast&lt;unsigned char&gt;(text[0]) == 0xEF &amp;&amp; 
<a name="l01733"></a>01733                 static_cast&lt;unsigned char&gt;(text[1]) == 0xBB &amp;&amp; 
<a name="l01734"></a>01734                 static_cast&lt;unsigned char&gt;(text[2]) == 0xBF)
<a name="l01735"></a>01735             {
<a name="l01736"></a>01736                 text += 3;      <span class="comment">// Skup utf-8 bom</span>
<a name="l01737"></a>01737             }
<a name="l01738"></a>01738         }
<a name="l01739"></a>01739 
<a name="l01740"></a>01740         <span class="comment">// Parse XML declaration (&lt;?xml...)</span>
<a name="l01741"></a>01741         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01742"></a>01742         xml_node&lt;Ch&gt; *parse_xml_declaration(Ch *&amp;text)
<a name="l01743"></a>01743         {
<a name="l01744"></a>01744             <span class="comment">// If parsing of declaration is disabled</span>
<a name="l01745"></a>01745             <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a999d782659513f8015ea4236e3204c42">parse_declaration_node</a>))
<a name="l01746"></a>01746             {
<a name="l01747"></a>01747                 <span class="comment">// Skip until end of declaration</span>
<a name="l01748"></a>01748                 <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;?&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01749"></a>01749                 {
<a name="l01750"></a>01750                     <span class="keywordflow">if</span> (!text[0])
<a name="l01751"></a>01751                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01752"></a>01752                     ++text;
<a name="l01753"></a>01753                 }
<a name="l01754"></a>01754                 text += 2;    <span class="comment">// Skip &#39;?&gt;&#39;</span>
<a name="l01755"></a>01755                 <span class="keywordflow">return</span> 0;
<a name="l01756"></a>01756             }
<a name="l01757"></a>01757 
<a name="l01758"></a>01758             <span class="comment">// Create declaration</span>
<a name="l01759"></a>01759             xml_node&lt;Ch&gt; *declaration = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7cafe4ca44261e5fbedf0eab43131751212" title="A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalon...">node_declaration</a>);
<a name="l01760"></a>01760 
<a name="l01761"></a>01761             <span class="comment">// Skip whitespace before attributes or ?&gt;</span>
<a name="l01762"></a>01762             skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l01763"></a>01763 
<a name="l01764"></a>01764             <span class="comment">// Parse declaration attributes</span>
<a name="l01765"></a>01765             parse_node_attributes&lt;Flags&gt;(text, declaration);
<a name="l01766"></a>01766             
<a name="l01767"></a>01767             <span class="comment">// Skip ?&gt;</span>
<a name="l01768"></a>01768             <span class="keywordflow">if</span> (text[0] != Ch(<span class="charliteral">&#39;?&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01769"></a>01769                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected ?&gt;&quot;</span>, text);
<a name="l01770"></a>01770             text += 2;
<a name="l01771"></a>01771             
<a name="l01772"></a>01772             <span class="keywordflow">return</span> declaration;
<a name="l01773"></a>01773         }
<a name="l01774"></a>01774 
<a name="l01775"></a>01775         <span class="comment">// Parse XML comment (&lt;!--...)</span>
<a name="l01776"></a>01776         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01777"></a>01777         xml_node&lt;Ch&gt; *parse_comment(Ch *&amp;text)
<a name="l01778"></a>01778         {
<a name="l01779"></a>01779             <span class="comment">// If parsing of comments is disabled</span>
<a name="l01780"></a>01780             <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#ae093dd49e2f59fa39eee95f1a6568e32">parse_comment_nodes</a>))
<a name="l01781"></a>01781             {
<a name="l01782"></a>01782                 <span class="comment">// Skip until end of comment</span>
<a name="l01783"></a>01783                 <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;-&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;-&#39;</span>) || text[2] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01784"></a>01784                 {
<a name="l01785"></a>01785                     <span class="keywordflow">if</span> (!text[0])
<a name="l01786"></a>01786                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01787"></a>01787                     ++text;
<a name="l01788"></a>01788                 }
<a name="l01789"></a>01789                 text += 3;     <span class="comment">// Skip &#39;--&gt;&#39;</span>
<a name="l01790"></a>01790                 <span class="keywordflow">return</span> 0;      <span class="comment">// Do not produce comment node</span>
<a name="l01791"></a>01791             }
<a name="l01792"></a>01792 
<a name="l01793"></a>01793             <span class="comment">// Remember value start</span>
<a name="l01794"></a>01794             Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#adcdaccff61c665f039d9344e447b7445">value</a> = text;
<a name="l01795"></a>01795 
<a name="l01796"></a>01796             <span class="comment">// Skip until end of comment</span>
<a name="l01797"></a>01797             <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;-&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;-&#39;</span>) || text[2] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01798"></a>01798             {
<a name="l01799"></a>01799                 <span class="keywordflow">if</span> (!text[0])
<a name="l01800"></a>01800                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01801"></a>01801                 ++text;
<a name="l01802"></a>01802             }
<a name="l01803"></a>01803 
<a name="l01804"></a>01804             <span class="comment">// Create comment node</span>
<a name="l01805"></a>01805             xml_node&lt;Ch&gt; *comment = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca1a695e1384ec3bd4df3eff65ec609a96" title="A comment node. Name is empty. Value contains comment text.">node_comment</a>);
<a name="l01806"></a>01806             comment-&gt;value(value, text - value);
<a name="l01807"></a>01807             
<a name="l01808"></a>01808             <span class="comment">// Place zero terminator after comment value</span>
<a name="l01809"></a>01809             <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">parse_no_string_terminators</a>))
<a name="l01810"></a>01810                 *text = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l01811"></a>01811             
<a name="l01812"></a>01812             text += 3;     <span class="comment">// Skip &#39;--&gt;&#39;</span>
<a name="l01813"></a>01813             <span class="keywordflow">return</span> comment;
<a name="l01814"></a>01814         }
<a name="l01815"></a>01815 
<a name="l01816"></a>01816         <span class="comment">// Parse DOCTYPE</span>
<a name="l01817"></a>01817         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01818"></a>01818         xml_node&lt;Ch&gt; *parse_doctype(Ch *&amp;text)
<a name="l01819"></a>01819         {
<a name="l01820"></a>01820             <span class="comment">// Remember value start</span>
<a name="l01821"></a>01821             Ch *value = text;
<a name="l01822"></a>01822 
<a name="l01823"></a>01823             <span class="comment">// Skip to &gt;</span>
<a name="l01824"></a>01824             <span class="keywordflow">while</span> (*text != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01825"></a>01825             {
<a name="l01826"></a>01826                 <span class="comment">// Determine character type</span>
<a name="l01827"></a>01827                 <span class="keywordflow">switch</span> (*text)
<a name="l01828"></a>01828                 {
<a name="l01829"></a>01829                 
<a name="l01830"></a>01830                 <span class="comment">// If &#39;[&#39; encountered, scan for matching ending &#39;]&#39; using naive algorithm with depth</span>
<a name="l01831"></a>01831                 <span class="comment">// This works for all W3C test files except for 2 most wicked</span>
<a name="l01832"></a>01832                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;[&#39;</span>):
<a name="l01833"></a>01833                 {
<a name="l01834"></a>01834                     ++text;     <span class="comment">// Skip &#39;[&#39;</span>
<a name="l01835"></a>01835                     <span class="keywordtype">int</span> depth = 1;
<a name="l01836"></a>01836                     <span class="keywordflow">while</span> (depth &gt; 0)
<a name="l01837"></a>01837                     {
<a name="l01838"></a>01838                         <span class="keywordflow">switch</span> (*text)
<a name="l01839"></a>01839                         {
<a name="l01840"></a>01840                             <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;[&#39;</span>): ++depth; <span class="keywordflow">break</span>;
<a name="l01841"></a>01841                             <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;]&#39;</span>): --depth; <span class="keywordflow">break</span>;
<a name="l01842"></a>01842                             <span class="keywordflow">case</span> 0: <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01843"></a>01843                         }
<a name="l01844"></a>01844                         ++text;
<a name="l01845"></a>01845                     }
<a name="l01846"></a>01846                     <span class="keywordflow">break</span>;
<a name="l01847"></a>01847                 }
<a name="l01848"></a>01848                 
<a name="l01849"></a>01849                 <span class="comment">// Error on end of text</span>
<a name="l01850"></a>01850                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;\0&#39;</span>):
<a name="l01851"></a>01851                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01852"></a>01852                 
<a name="l01853"></a>01853                 <span class="comment">// Other character, skip it</span>
<a name="l01854"></a>01854                 <span class="keywordflow">default</span>:
<a name="l01855"></a>01855                     ++text;
<a name="l01856"></a>01856 
<a name="l01857"></a>01857                 }
<a name="l01858"></a>01858             }
<a name="l01859"></a>01859             
<a name="l01860"></a>01860             <span class="comment">// If DOCTYPE nodes enabled</span>
<a name="l01861"></a>01861             <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a41002b49780a90a0bbcc28ce8b895fe4">parse_doctype_node</a>)
<a name="l01862"></a>01862             {
<a name="l01863"></a>01863                 <span class="comment">// Create a new doctype node</span>
<a name="l01864"></a>01864                 xml_node&lt;Ch&gt; *doctype = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7cadf5002f2efabe231bed01d16f08f832c" title="A DOCTYPE node. Name is empty. Value contains DOCTYPE text.">node_doctype</a>);
<a name="l01865"></a>01865                 doctype-&gt;value(value, text - value);
<a name="l01866"></a>01866                 
<a name="l01867"></a>01867                 <span class="comment">// Place zero terminator after value</span>
<a name="l01868"></a>01868                 <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">parse_no_string_terminators</a>))
<a name="l01869"></a>01869                     *text = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l01870"></a>01870 
<a name="l01871"></a>01871                 text += 1;      <span class="comment">// skip &#39;&gt;&#39;</span>
<a name="l01872"></a>01872                 <span class="keywordflow">return</span> doctype;
<a name="l01873"></a>01873             }
<a name="l01874"></a>01874             <span class="keywordflow">else</span>
<a name="l01875"></a>01875             {
<a name="l01876"></a>01876                 text += 1;      <span class="comment">// skip &#39;&gt;&#39;</span>
<a name="l01877"></a>01877                 <span class="keywordflow">return</span> 0;
<a name="l01878"></a>01878             }
<a name="l01879"></a>01879 
<a name="l01880"></a>01880         }
<a name="l01881"></a>01881 
<a name="l01882"></a>01882         <span class="comment">// Parse PI</span>
<a name="l01883"></a>01883         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01884"></a>01884         xml_node&lt;Ch&gt; *parse_pi(Ch *&amp;text)
<a name="l01885"></a>01885         {
<a name="l01886"></a>01886             <span class="comment">// If creation of PI nodes is enabled</span>
<a name="l01887"></a>01887             <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a03fe68fcf5d28f38476e0fd31adecc4c">parse_pi_nodes</a>)
<a name="l01888"></a>01888             {
<a name="l01889"></a>01889                 <span class="comment">// Create pi node</span>
<a name="l01890"></a>01890                 xml_node&lt;Ch&gt; *pi = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7caeb73b472e77347b9aa89525f16493b87" title="A PI node. Name contains target. Value contains instructions.">node_pi</a>);
<a name="l01891"></a>01891 
<a name="l01892"></a>01892                 <span class="comment">// Extract PI target name</span>
<a name="l01893"></a>01893                 Ch *<a class="code" href="../../d4/d48/classrapidxml_1_1xml__base.html#a9a09739310469995db078ebd0da3ed45">name</a> = text;
<a name="l01894"></a>01894                 skip&lt;node_name_pred, Flags&gt;(text);
<a name="l01895"></a>01895                 <span class="keywordflow">if</span> (text == name)
<a name="l01896"></a>01896                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected PI target&quot;</span>, text);
<a name="l01897"></a>01897                 pi-&gt;name(name, text - name);
<a name="l01898"></a>01898                 
<a name="l01899"></a>01899                 <span class="comment">// Skip whitespace between pi target and pi</span>
<a name="l01900"></a>01900                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l01901"></a>01901 
<a name="l01902"></a>01902                 <span class="comment">// Remember start of pi</span>
<a name="l01903"></a>01903                 Ch *value = text;
<a name="l01904"></a>01904                 
<a name="l01905"></a>01905                 <span class="comment">// Skip to &#39;?&gt;&#39;</span>
<a name="l01906"></a>01906                 <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;?&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01907"></a>01907                 {
<a name="l01908"></a>01908                     <span class="keywordflow">if</span> (*text == Ch(<span class="charliteral">&#39;\0&#39;</span>))
<a name="l01909"></a>01909                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01910"></a>01910                     ++text;
<a name="l01911"></a>01911                 }
<a name="l01912"></a>01912 
<a name="l01913"></a>01913                 <span class="comment">// Set pi value (verbatim, no entity expansion or whitespace normalization)</span>
<a name="l01914"></a>01914                 pi-&gt;value(value, text - value);     
<a name="l01915"></a>01915                 
<a name="l01916"></a>01916                 <span class="comment">// Place zero terminator after name and value</span>
<a name="l01917"></a>01917                 <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#af3fc88ba6bee33482a2db81b1da36ea1">parse_no_string_terminators</a>))
<a name="l01918"></a>01918                 {
<a name="l01919"></a>01919                     pi-&gt;name()[pi-&gt;name_size()] = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l01920"></a>01920                     pi-&gt;value()[pi-&gt;value_size()] = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l01921"></a>01921                 }
<a name="l01922"></a>01922                 
<a name="l01923"></a>01923                 text += 2;                          <span class="comment">// Skip &#39;?&gt;&#39;</span>
<a name="l01924"></a>01924                 <span class="keywordflow">return</span> pi;
<a name="l01925"></a>01925             }
<a name="l01926"></a>01926             <span class="keywordflow">else</span>
<a name="l01927"></a>01927             {
<a name="l01928"></a>01928                 <span class="comment">// Skip to &#39;?&gt;&#39;</span>
<a name="l01929"></a>01929                 <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;?&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l01930"></a>01930                 {
<a name="l01931"></a>01931                     <span class="keywordflow">if</span> (*text == Ch(<span class="charliteral">&#39;\0&#39;</span>))
<a name="l01932"></a>01932                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l01933"></a>01933                     ++text;
<a name="l01934"></a>01934                 }
<a name="l01935"></a>01935                 text += 2;    <span class="comment">// Skip &#39;?&gt;&#39;</span>
<a name="l01936"></a>01936                 <span class="keywordflow">return</span> 0;
<a name="l01937"></a>01937             }
<a name="l01938"></a>01938         }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940         <span class="comment">// Parse and append data</span>
<a name="l01941"></a>01941         <span class="comment">// Return character that ends data.</span>
<a name="l01942"></a>01942         <span class="comment">// This is necessary because this character might have been overwritten by a terminating 0</span>
<a name="l01943"></a>01943         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l01944"></a>01944         Ch parse_and_append_data(xml_node&lt;Ch&gt; *node, Ch *&amp;text, Ch *contents_start)
<a name="l01945"></a>01945         {
<a name="l01946"></a>01946             <span class="comment">// Backup to contents start if whitespace trimming is disabled</span>
<a name="l01947"></a>01947             <span class="keywordflow">if</span> (!(Flags &amp; parse_trim_whitespace))
<a name="l01948"></a>01948                 text = contents_start;     
<a name="l01949"></a>01949             
<a name="l01950"></a>01950             <span class="comment">// Skip until end of data</span>
<a name="l01951"></a>01951             Ch *value = text, *end;
<a name="l01952"></a>01952             <span class="keywordflow">if</span> (Flags &amp; parse_normalize_whitespace)
<a name="l01953"></a>01953                 end = skip_and_expand_character_refs&lt;text_pred, text_pure_with_ws_pred, Flags&gt;(text);   
<a name="l01954"></a>01954             <span class="keywordflow">else</span>
<a name="l01955"></a>01955                 end = skip_and_expand_character_refs&lt;text_pred, text_pure_no_ws_pred, Flags&gt;(text);
<a name="l01956"></a>01956 
<a name="l01957"></a>01957             <span class="comment">// Trim trailing whitespace if flag is set; leading was already trimmed by whitespace skip after &gt;</span>
<a name="l01958"></a>01958             <span class="keywordflow">if</span> (Flags &amp; parse_trim_whitespace)
<a name="l01959"></a>01959             {
<a name="l01960"></a>01960                 <span class="keywordflow">if</span> (Flags &amp; parse_normalize_whitespace)
<a name="l01961"></a>01961                 {
<a name="l01962"></a>01962                     <span class="comment">// Whitespace is already condensed to single space characters by skipping function, so just trim 1 char off the end</span>
<a name="l01963"></a>01963                     <span class="keywordflow">if</span> (*(end - 1) == Ch(<span class="charliteral">&#39; &#39;</span>))
<a name="l01964"></a>01964                         --end;
<a name="l01965"></a>01965                 }
<a name="l01966"></a>01966                 <span class="keywordflow">else</span>
<a name="l01967"></a>01967                 {
<a name="l01968"></a>01968                     <span class="comment">// Backup until non-whitespace character is found</span>
<a name="l01969"></a>01969                     <span class="keywordflow">while</span> (whitespace_pred::test(*(end - 1)))
<a name="l01970"></a>01970                         --end;
<a name="l01971"></a>01971                 }
<a name="l01972"></a>01972             }
<a name="l01973"></a>01973             
<a name="l01974"></a>01974             <span class="comment">// If characters are still left between end and value (this test is only necessary if normalization is enabled)</span>
<a name="l01975"></a>01975             <span class="comment">// Create new data node</span>
<a name="l01976"></a>01976             <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#ac2d21ef14a4e8936b94aca5d38b1a74d">parse_no_data_nodes</a>))
<a name="l01977"></a>01977             {
<a name="l01978"></a>01978                 xml_node&lt;Ch&gt; *data = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca9d669d8e1f4ba9c7eeada4c14a11ad1d" title="A data node. Name is empty. Value contains data text.">node_data</a>);
<a name="l01979"></a>01979                 data-&gt;value(value, end - value);
<a name="l01980"></a>01980                 node-&gt;append_node(data);
<a name="l01981"></a>01981             }
<a name="l01982"></a>01982 
<a name="l01983"></a>01983             <span class="comment">// Add data to parent node if no data exists yet</span>
<a name="l01984"></a>01984             <span class="keywordflow">if</span> (!(Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a00e6fea134b786ea6efeed1c8bc4a668">parse_no_element_values</a>)) 
<a name="l01985"></a>01985                 <span class="keywordflow">if</span> (*node-&gt;value() == Ch(<span class="charliteral">&#39;\0&#39;</span>))
<a name="l01986"></a>01986                     node-&gt;value(value, end - value);
<a name="l01987"></a>01987 
<a name="l01988"></a>01988             <span class="comment">// Place zero terminator after value</span>
<a name="l01989"></a>01989             <span class="keywordflow">if</span> (!(Flags &amp; parse_no_string_terminators))
<a name="l01990"></a>01990             {
<a name="l01991"></a>01991                 Ch ch = *text;
<a name="l01992"></a>01992                 *end = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l01993"></a>01993                 <span class="keywordflow">return</span> ch;      <span class="comment">// Return character that ends data; this is required because zero terminator overwritten it</span>
<a name="l01994"></a>01994             }
<a name="l01995"></a>01995 
<a name="l01996"></a>01996             <span class="comment">// Return character that ends data</span>
<a name="l01997"></a>01997             <span class="keywordflow">return</span> *text;
<a name="l01998"></a>01998         }
<a name="l01999"></a>01999 
<a name="l02000"></a>02000         <span class="comment">// Parse CDATA</span>
<a name="l02001"></a>02001         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l02002"></a>02002         xml_node&lt;Ch&gt; *parse_cdata(Ch *&amp;text)
<a name="l02003"></a>02003         {
<a name="l02004"></a>02004             <span class="comment">// If CDATA is disabled</span>
<a name="l02005"></a>02005             <span class="keywordflow">if</span> (Flags &amp; parse_no_data_nodes)
<a name="l02006"></a>02006             {
<a name="l02007"></a>02007                 <span class="comment">// Skip until end of cdata</span>
<a name="l02008"></a>02008                 <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;]&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;]&#39;</span>) || text[2] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02009"></a>02009                 {
<a name="l02010"></a>02010                     <span class="keywordflow">if</span> (!text[0])
<a name="l02011"></a>02011                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l02012"></a>02012                     ++text;
<a name="l02013"></a>02013                 }
<a name="l02014"></a>02014                 text += 3;      <span class="comment">// Skip ]]&gt;</span>
<a name="l02015"></a>02015                 <span class="keywordflow">return</span> 0;       <span class="comment">// Do not produce CDATA node</span>
<a name="l02016"></a>02016             }
<a name="l02017"></a>02017 
<a name="l02018"></a>02018             <span class="comment">// Skip until end of cdata</span>
<a name="l02019"></a>02019             Ch *value = text;
<a name="l02020"></a>02020             <span class="keywordflow">while</span> (text[0] != Ch(<span class="charliteral">&#39;]&#39;</span>) || text[1] != Ch(<span class="charliteral">&#39;]&#39;</span>) || text[2] != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02021"></a>02021             {
<a name="l02022"></a>02022                 <span class="keywordflow">if</span> (!text[0])
<a name="l02023"></a>02023                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l02024"></a>02024                 ++text;
<a name="l02025"></a>02025             }
<a name="l02026"></a>02026 
<a name="l02027"></a>02027             <span class="comment">// Create new cdata node</span>
<a name="l02028"></a>02028             xml_node&lt;Ch&gt; *cdata = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7caccf0b363d3876a3f83ff9b1bcdaaa536" title="A CDATA node. Name is empty. Value contains data text.">node_cdata</a>);
<a name="l02029"></a>02029             cdata-&gt;value(value, text - value);
<a name="l02030"></a>02030 
<a name="l02031"></a>02031             <span class="comment">// Place zero terminator after value</span>
<a name="l02032"></a>02032             <span class="keywordflow">if</span> (!(Flags &amp; parse_no_string_terminators))
<a name="l02033"></a>02033                 *text = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l02034"></a>02034 
<a name="l02035"></a>02035             text += 3;      <span class="comment">// Skip ]]&gt;</span>
<a name="l02036"></a>02036             <span class="keywordflow">return</span> cdata;
<a name="l02037"></a>02037         }
<a name="l02038"></a>02038         
<a name="l02039"></a>02039         <span class="comment">// Parse element node</span>
<a name="l02040"></a>02040         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l02041"></a>02041         xml_node&lt;Ch&gt; *parse_element(Ch *&amp;text)
<a name="l02042"></a>02042         {
<a name="l02043"></a>02043             <span class="comment">// Create element node</span>
<a name="l02044"></a>02044             xml_node&lt;Ch&gt; *element = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a4118581c29ee9a2f6b55ebf7dac185f8">allocate_node</a>(<a class="code" href="../../d7/d8a/namespacerapidxml.html#abb456db38f7efb746c4330eed6072a7ca89cbeb4d28046326e4ee953d3c4047ff" title="An element node. Name contains element name. Value contains text of first data node.">node_element</a>);
<a name="l02045"></a>02045 
<a name="l02046"></a>02046             <span class="comment">// Extract element name</span>
<a name="l02047"></a>02047             Ch *name = text;
<a name="l02048"></a>02048             skip&lt;node_name_pred, Flags&gt;(text);
<a name="l02049"></a>02049             <span class="keywordflow">if</span> (text == name)
<a name="l02050"></a>02050                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected element name&quot;</span>, text);
<a name="l02051"></a>02051             element-&gt;name(name, text - name);
<a name="l02052"></a>02052             
<a name="l02053"></a>02053             <span class="comment">// Skip whitespace between element name and attributes or &gt;</span>
<a name="l02054"></a>02054             skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02055"></a>02055 
<a name="l02056"></a>02056             <span class="comment">// Parse attributes, if any</span>
<a name="l02057"></a>02057             parse_node_attributes&lt;Flags&gt;(text, element);
<a name="l02058"></a>02058 
<a name="l02059"></a>02059             <span class="comment">// Determine ending type</span>
<a name="l02060"></a>02060             <span class="keywordflow">if</span> (*text == Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02061"></a>02061             {
<a name="l02062"></a>02062                 ++text;
<a name="l02063"></a>02063                 parse_node_contents&lt;Flags&gt;(text, element);
<a name="l02064"></a>02064             }
<a name="l02065"></a>02065             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*text == Ch(<span class="charliteral">&#39;/&#39;</span>))
<a name="l02066"></a>02066             {
<a name="l02067"></a>02067                 ++text;
<a name="l02068"></a>02068                 <span class="keywordflow">if</span> (*text != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02069"></a>02069                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &gt;&quot;</span>, text);
<a name="l02070"></a>02070                 ++text;
<a name="l02071"></a>02071             }
<a name="l02072"></a>02072             <span class="keywordflow">else</span>
<a name="l02073"></a>02073                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &gt;&quot;</span>, text);
<a name="l02074"></a>02074 
<a name="l02075"></a>02075             <span class="comment">// Place zero terminator after name</span>
<a name="l02076"></a>02076             <span class="keywordflow">if</span> (!(Flags &amp; parse_no_string_terminators))
<a name="l02077"></a>02077                 element-&gt;name()[element-&gt;name_size()] = Ch(<span class="charliteral">&#39;\0&#39;</span>);
<a name="l02078"></a>02078 
<a name="l02079"></a>02079             <span class="comment">// Return parsed element</span>
<a name="l02080"></a>02080             <span class="keywordflow">return</span> element;
<a name="l02081"></a>02081         }
<a name="l02082"></a>02082 
<a name="l02083"></a>02083         <span class="comment">// Determine node type, and parse it</span>
<a name="l02084"></a>02084         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l02085"></a>02085         xml_node&lt;Ch&gt; *parse_node(Ch *&amp;text)
<a name="l02086"></a>02086         {
<a name="l02087"></a>02087             <span class="comment">// Parse proper node type</span>
<a name="l02088"></a>02088             <span class="keywordflow">switch</span> (text[0])
<a name="l02089"></a>02089             {
<a name="l02090"></a>02090 
<a name="l02091"></a>02091             <span class="comment">// &lt;...</span>
<a name="l02092"></a>02092             <span class="keywordflow">default</span>: 
<a name="l02093"></a>02093                 <span class="comment">// Parse and append element node</span>
<a name="l02094"></a>02094                 <span class="keywordflow">return</span> parse_element&lt;Flags&gt;(text);
<a name="l02095"></a>02095 
<a name="l02096"></a>02096             <span class="comment">// &lt;?...</span>
<a name="l02097"></a>02097             <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;?&#39;</span>): 
<a name="l02098"></a>02098                 ++text;     <span class="comment">// Skip ?</span>
<a name="l02099"></a>02099                 <span class="keywordflow">if</span> ((text[0] == Ch(<span class="charliteral">&#39;x&#39;</span>) || text[0] == Ch(<span class="charliteral">&#39;X&#39;</span>)) &amp;&amp;
<a name="l02100"></a>02100                     (text[1] == Ch(<span class="charliteral">&#39;m&#39;</span>) || text[1] == Ch(<span class="charliteral">&#39;M&#39;</span>)) &amp;&amp; 
<a name="l02101"></a>02101                     (text[2] == Ch(<span class="charliteral">&#39;l&#39;</span>) || text[2] == Ch(<span class="charliteral">&#39;L&#39;</span>)) &amp;&amp;
<a name="l02102"></a>02102                     whitespace_pred::test(text[3]))
<a name="l02103"></a>02103                 {
<a name="l02104"></a>02104                     <span class="comment">// &#39;&lt;?xml &#39; - xml declaration</span>
<a name="l02105"></a>02105                     text += 4;      <span class="comment">// Skip &#39;xml &#39;</span>
<a name="l02106"></a>02106                     <span class="keywordflow">return</span> parse_xml_declaration&lt;Flags&gt;(text);
<a name="l02107"></a>02107                 }
<a name="l02108"></a>02108                 <span class="keywordflow">else</span>
<a name="l02109"></a>02109                 {
<a name="l02110"></a>02110                     <span class="comment">// Parse PI</span>
<a name="l02111"></a>02111                     <span class="keywordflow">return</span> parse_pi&lt;Flags&gt;(text);
<a name="l02112"></a>02112                 }
<a name="l02113"></a>02113             
<a name="l02114"></a>02114             <span class="comment">// &lt;!...</span>
<a name="l02115"></a>02115             <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;!&#39;</span>): 
<a name="l02116"></a>02116 
<a name="l02117"></a>02117                 <span class="comment">// Parse proper subset of &lt;! node</span>
<a name="l02118"></a>02118                 switch (text[1])    
<a name="l02119"></a>02119                 {
<a name="l02120"></a>02120                 
<a name="l02121"></a>02121                 <span class="comment">// &lt;!-</span>
<a name="l02122"></a>02122                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;-&#39;</span>):
<a name="l02123"></a>02123                     if (text[2] == Ch(<span class="stringliteral">&#39;-&#39;</span>))
<a name="l02124"></a>02124                     {
<a name="l02125"></a>02125                         <span class="comment">// &#39;&lt;!--&#39; - xml comment</span>
<a name="l02126"></a>02126                         text += 3;     <span class="comment">// Skip &#39;!--&#39;</span>
<a name="l02127"></a>02127                         <span class="keywordflow">return</span> parse_comment&lt;Flags&gt;(text);
<a name="l02128"></a>02128                     }
<a name="l02129"></a>02129                     <span class="keywordflow">break</span>;
<a name="l02130"></a>02130 
<a name="l02131"></a>02131                 <span class="comment">// &lt;![</span>
<a name="l02132"></a>02132                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;[&#39;</span>):
<a name="l02133"></a>02133                     if (text[2] == Ch(<span class="stringliteral">&#39;C&#39;</span>) &amp;&amp; text[3] == Ch(<span class="stringliteral">&#39;D&#39;</span>) &amp;&amp; text[4] == Ch(<span class="stringliteral">&#39;A&#39;</span>) &amp;&amp; 
<a name="l02134"></a>02134                         text[5] == Ch(<span class="stringliteral">&#39;T&#39;</span>) &amp;&amp; text[6] == Ch(<span class="stringliteral">&#39;A&#39;</span>) &amp;&amp; text[7] == Ch(<span class="stringliteral">&#39;[&#39;</span>))
<a name="l02135"></a>02135                     {
<a name="l02136"></a>02136                         <span class="comment">// &#39;&lt;![CDATA[&#39; - cdata</span>
<a name="l02137"></a>02137                         text += 8;     <span class="comment">// Skip &#39;![CDATA[&#39;</span>
<a name="l02138"></a>02138                         <span class="keywordflow">return</span> parse_cdata&lt;Flags&gt;(text);
<a name="l02139"></a>02139                     }
<a name="l02140"></a>02140                     <span class="keywordflow">break</span>;
<a name="l02141"></a>02141 
<a name="l02142"></a>02142                 <span class="comment">// &lt;!D</span>
<a name="l02143"></a>02143                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;D&#39;</span>):
<a name="l02144"></a>02144                     if (text[2] == Ch(<span class="stringliteral">&#39;O&#39;</span>) &amp;&amp; text[3] == Ch(<span class="stringliteral">&#39;C&#39;</span>) &amp;&amp; text[4] == Ch(<span class="stringliteral">&#39;T&#39;</span>) &amp;&amp; 
<a name="l02145"></a>02145                         text[5] == Ch(<span class="stringliteral">&#39;Y&#39;</span>) &amp;&amp; text[6] == Ch(<span class="stringliteral">&#39;P&#39;</span>) &amp;&amp; text[7] == Ch(<span class="stringliteral">&#39;E&#39;</span>) &amp;&amp; 
<a name="l02146"></a>02146                         whitespace_pred::test(text[8]))
<a name="l02147"></a>02147                     {
<a name="l02148"></a>02148                         <span class="comment">// &#39;&lt;!DOCTYPE &#39; - doctype</span>
<a name="l02149"></a>02149                         text += 9;      <span class="comment">// skip &#39;!DOCTYPE &#39;</span>
<a name="l02150"></a>02150                         <span class="keywordflow">return</span> parse_doctype&lt;Flags&gt;(text);
<a name="l02151"></a>02151                     }
<a name="l02152"></a>02152 
<a name="l02153"></a>02153                 }   <span class="comment">// switch</span>
<a name="l02154"></a>02154 
<a name="l02155"></a>02155                 <span class="comment">// Attempt to skip other, unrecognized node types starting with &lt;!</span>
<a name="l02156"></a>02156                 ++text;     <span class="comment">// Skip !</span>
<a name="l02157"></a>02157                 <span class="keywordflow">while</span> (*text != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02158"></a>02158                 {
<a name="l02159"></a>02159                     <span class="keywordflow">if</span> (*text == 0)
<a name="l02160"></a>02160                         <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l02161"></a>02161                     ++text;
<a name="l02162"></a>02162                 }
<a name="l02163"></a>02163                 ++text;     <span class="comment">// Skip &#39;&gt;&#39;</span>
<a name="l02164"></a>02164                 <span class="keywordflow">return</span> 0;   <span class="comment">// No node recognized</span>
<a name="l02165"></a>02165 
<a name="l02166"></a>02166             }
<a name="l02167"></a>02167         }
<a name="l02168"></a>02168 
<a name="l02169"></a>02169         <span class="comment">// Parse contents of the node - children, data etc.</span>
<a name="l02170"></a>02170         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l02171"></a>02171         <span class="keywordtype">void</span> parse_node_contents(Ch *&amp;text, xml_node&lt;Ch&gt; *node)
<a name="l02172"></a>02172         {
<a name="l02173"></a>02173             <span class="comment">// For all children and text</span>
<a name="l02174"></a>02174             <span class="keywordflow">while</span> (1)
<a name="l02175"></a>02175             {
<a name="l02176"></a>02176                 <span class="comment">// Skip whitespace between &gt; and node contents</span>
<a name="l02177"></a>02177                 Ch *contents_start = text;      <span class="comment">// Store start of node contents before whitespace is skipped</span>
<a name="l02178"></a>02178                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02179"></a>02179                 Ch next_char = *text;
<a name="l02180"></a>02180 
<a name="l02181"></a>02181             <span class="comment">// After data nodes, instead of continuing the loop, control jumps here.</span>
<a name="l02182"></a>02182             <span class="comment">// This is because zero termination inside parse_and_append_data() function</span>
<a name="l02183"></a>02183             <span class="comment">// would wreak havoc with the above code.</span>
<a name="l02184"></a>02184             <span class="comment">// Also, skipping whitespace after data nodes is unnecessary.</span>
<a name="l02185"></a>02185             after_data_node:    
<a name="l02186"></a>02186                 
<a name="l02187"></a>02187                 <span class="comment">// Determine what comes next: node closing, child node, data node, or 0?</span>
<a name="l02188"></a>02188                 <span class="keywordflow">switch</span> (next_char)
<a name="l02189"></a>02189                 {
<a name="l02190"></a>02190                 
<a name="l02191"></a>02191                 <span class="comment">// Node closing or child node</span>
<a name="l02192"></a>02192                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;&lt;&#39;</span>):
<a name="l02193"></a>02193                     if (text[1] == Ch(<span class="stringliteral">&#39;/&#39;</span>))
<a name="l02194"></a>02194                     {
<a name="l02195"></a>02195                         <span class="comment">// Node closing</span>
<a name="l02196"></a>02196                         text += 2;      <span class="comment">// Skip &#39;&lt;/&#39;</span>
<a name="l02197"></a>02197                         <span class="keywordflow">if</span> (Flags &amp; <a class="code" href="../../d7/d8a/namespacerapidxml.html#a7ce8f40fda68338e20b56f41e48e49f3">parse_validate_closing_tags</a>)
<a name="l02198"></a>02198                         {
<a name="l02199"></a>02199                             <span class="comment">// Skip and validate closing tag name</span>
<a name="l02200"></a>02200                             Ch *closing_name = text;
<a name="l02201"></a>02201                             skip&lt;node_name_pred, Flags&gt;(text);
<a name="l02202"></a>02202                             <span class="keywordflow">if</span> (!internal::compare(node-&gt;name(), node-&gt;name_size(), closing_name, text - closing_name, <span class="keyword">true</span>))
<a name="l02203"></a>02203                                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;invalid closing tag name&quot;</span>, text);
<a name="l02204"></a>02204                         }
<a name="l02205"></a>02205                         <span class="keywordflow">else</span>
<a name="l02206"></a>02206                         {
<a name="l02207"></a>02207                             <span class="comment">// No validation, just skip name</span>
<a name="l02208"></a>02208                             skip&lt;node_name_pred, Flags&gt;(text);
<a name="l02209"></a>02209                         }
<a name="l02210"></a>02210                         <span class="comment">// Skip remaining whitespace after node name</span>
<a name="l02211"></a>02211                         skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02212"></a>02212                         <span class="keywordflow">if</span> (*text != Ch(<span class="charliteral">&#39;&gt;&#39;</span>))
<a name="l02213"></a>02213                             <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &gt;&quot;</span>, text);
<a name="l02214"></a>02214                         ++text;     <span class="comment">// Skip &#39;&gt;&#39;</span>
<a name="l02215"></a>02215                         <span class="keywordflow">return</span>;     <span class="comment">// Node closed, finished parsing contents</span>
<a name="l02216"></a>02216                     }
<a name="l02217"></a>02217                     <span class="keywordflow">else</span>
<a name="l02218"></a>02218                     {
<a name="l02219"></a>02219                         <span class="comment">// Child node</span>
<a name="l02220"></a>02220                         ++text;     <span class="comment">// Skip &#39;&lt;&#39;</span>
<a name="l02221"></a>02221                         xml_node&lt;Ch&gt; *child;
<a name="l02222"></a>02222                         <span class="keywordflow">if</span> ((child = parse_node&lt;Flags&gt;(text)))
<a name="l02223"></a>02223                             node-&gt;append_node(child);
<a name="l02224"></a>02224                     }
<a name="l02225"></a>02225                     <span class="keywordflow">break</span>;
<a name="l02226"></a>02226 
<a name="l02227"></a>02227                 <span class="comment">// End of data - error</span>
<a name="l02228"></a>02228                 <span class="keywordflow">case</span> Ch(<span class="charliteral">&#39;\0&#39;</span>):
<a name="l02229"></a>02229                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;unexpected end of data&quot;</span>, text);
<a name="l02230"></a>02230 
<a name="l02231"></a>02231                 <span class="comment">// Data node</span>
<a name="l02232"></a>02232                 <span class="keywordflow">default</span>:
<a name="l02233"></a>02233                     next_char = parse_and_append_data&lt;Flags&gt;(node, text, contents_start);
<a name="l02234"></a>02234                     <span class="keywordflow">goto</span> after_data_node;   <span class="comment">// Bypass regular processing after data nodes</span>
<a name="l02235"></a>02235 
<a name="l02236"></a>02236                 }
<a name="l02237"></a>02237             }
<a name="l02238"></a>02238         }
<a name="l02239"></a>02239         
<a name="l02240"></a>02240         <span class="comment">// Parse XML attributes of the node</span>
<a name="l02241"></a>02241         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Flags&gt;
<a name="l02242"></a>02242         <span class="keywordtype">void</span> parse_node_attributes(Ch *&amp;text, xml_node&lt;Ch&gt; *node)
<a name="l02243"></a>02243         {
<a name="l02244"></a>02244             <span class="comment">// For all attributes </span>
<a name="l02245"></a>02245             <span class="keywordflow">while</span> (attribute_name_pred::test(*text))
<a name="l02246"></a>02246             {
<a name="l02247"></a>02247                 <span class="comment">// Extract attribute name</span>
<a name="l02248"></a>02248                 Ch *name = text;
<a name="l02249"></a>02249                 ++text;     <span class="comment">// Skip first character of attribute name</span>
<a name="l02250"></a>02250                 skip&lt;attribute_name_pred, Flags&gt;(text);
<a name="l02251"></a>02251                 <span class="keywordflow">if</span> (text == name)
<a name="l02252"></a>02252                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected attribute name&quot;</span>, name);
<a name="l02253"></a>02253 
<a name="l02254"></a>02254                 <span class="comment">// Create new attribute</span>
<a name="l02255"></a>02255                 xml_attribute&lt;Ch&gt; *attribute = this-&gt;<a class="code" href="../../d1/d46/classrapidxml_1_1memory__pool.html#a3de2a66c983336e006ea3844e244ed30">allocate_attribute</a>();
<a name="l02256"></a>02256                 attribute-&gt;name(name, text - name);
<a name="l02257"></a>02257                 node-&gt;append_attribute(attribute);
<a name="l02258"></a>02258 
<a name="l02259"></a>02259                 <span class="comment">// Skip whitespace after attribute name</span>
<a name="l02260"></a>02260                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02261"></a>02261 
<a name="l02262"></a>02262                 <span class="comment">// Skip =</span>
<a name="l02263"></a>02263                 <span class="keywordflow">if</span> (*text != Ch(<span class="charliteral">&#39;=&#39;</span>))
<a name="l02264"></a>02264                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected =&quot;</span>, text);
<a name="l02265"></a>02265                 ++text;
<a name="l02266"></a>02266 
<a name="l02267"></a>02267                 <span class="comment">// Add terminating zero after name</span>
<a name="l02268"></a>02268                 <span class="keywordflow">if</span> (!(Flags &amp; parse_no_string_terminators))
<a name="l02269"></a>02269                     attribute-&gt;name()[attribute-&gt;name_size()] = 0;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271                 <span class="comment">// Skip whitespace after =</span>
<a name="l02272"></a>02272                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02273"></a>02273 
<a name="l02274"></a>02274                 <span class="comment">// Skip quote and remember if it was &#39; or &quot;</span>
<a name="l02275"></a>02275                 Ch quote = *text;
<a name="l02276"></a>02276                 <span class="keywordflow">if</span> (quote != Ch(<span class="charliteral">&#39;\&#39;&#39;</span>) &amp;&amp; quote != Ch(<span class="charliteral">&#39;&quot;&#39;</span>))
<a name="l02277"></a>02277                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &#39; or \&quot;&quot;</span>, text);
<a name="l02278"></a>02278                 ++text;
<a name="l02279"></a>02279 
<a name="l02280"></a>02280                 <span class="comment">// Extract attribute value and expand char refs in it</span>
<a name="l02281"></a>02281                 Ch *value = text, *end;
<a name="l02282"></a>02282                 <span class="keyword">const</span> <span class="keywordtype">int</span> AttFlags = Flags &amp; ~parse_normalize_whitespace;   <span class="comment">// No whitespace normalization in attributes</span>
<a name="l02283"></a>02283                 <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a674dd1ba0db34c463bbf7e37ffef7a7c">_UNUSED</a>(AttFlags);
<a name="l02284"></a>02284                 <span class="keywordflow">if</span> (quote == Ch(<span class="charliteral">&#39;\&#39;&#39;</span>))
<a name="l02285"></a>02285                     end = skip_and_expand_character_refs&lt;attribute_value_pred&lt;Ch(&#39;\&#39;&#39;)&gt;, attribute_value_pure_pred&lt;Ch(&#39;\&#39;&#39;)&gt;, AttFlags&gt;(text);
<a name="l02286"></a>02286                 <span class="keywordflow">else</span>
<a name="l02287"></a>02287                     end = skip_and_expand_character_refs&lt;attribute_value_pred&lt;Ch(<span class="charliteral">&#39;&quot;&#39;</span>)&gt;, attribute_value_pure_pred&lt;Ch(<span class="charliteral">&#39;&quot;&#39;</span>)&gt;, AttFlags&gt;(text);
<a name="l02288"></a>02288                 
<a name="l02289"></a>02289                 <span class="comment">// Set attribute value</span>
<a name="l02290"></a>02290                 attribute-&gt;value(value, end - value);
<a name="l02291"></a>02291                 
<a name="l02292"></a>02292                 <span class="comment">// Make sure that end quote is present</span>
<a name="l02293"></a>02293                 <span class="keywordflow">if</span> (*text != quote)
<a name="l02294"></a>02294                     <a class="code" href="../../d7/d70/rapidxml_8hpp.html#a65f2be309896ffb841997d467c2f4fff">RAPIDXML_PARSE_ERROR</a>(<span class="stringliteral">&quot;expected &#39; or \&quot;&quot;</span>, text);
<a name="l02295"></a>02295                 ++text;     <span class="comment">// Skip quote</span>
<a name="l02296"></a>02296 
<a name="l02297"></a>02297                 <span class="comment">// Add terminating zero after value</span>
<a name="l02298"></a>02298                 <span class="keywordflow">if</span> (!(Flags &amp; parse_no_string_terminators))
<a name="l02299"></a>02299                     attribute-&gt;value()[attribute-&gt;value_size()] = 0;
<a name="l02300"></a>02300 
<a name="l02301"></a>02301                 <span class="comment">// Skip whitespace after attribute value</span>
<a name="l02302"></a>02302                 skip&lt;whitespace_pred, Flags&gt;(text);
<a name="l02303"></a>02303             }
<a name="l02304"></a>02304         }
<a name="l02305"></a>02305 
<a name="l02306"></a>02306     };
<a name="l02307"></a>02307 
<a name="l02309"></a>02309     <span class="keyword">namespace </span>internal
<a name="l02310"></a>02310     {
<a name="l02311"></a>02311 
<a name="l02312"></a>02312         <span class="comment">// Whitespace (space \n \r \t)</span>
<a name="l02313"></a>02313         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02314"></a>02314         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_whitespace[256] = 
<a name="l02315"></a>02315         {
<a name="l02316"></a>02316           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02317"></a>02317              0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  0,  0,  1,  0,  0,  <span class="comment">// 0</span>
<a name="l02318"></a>02318              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 1</span>
<a name="l02319"></a>02319              1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 2</span>
<a name="l02320"></a>02320              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 3</span>
<a name="l02321"></a>02321              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 4</span>
<a name="l02322"></a>02322              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 5</span>
<a name="l02323"></a>02323              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 6</span>
<a name="l02324"></a>02324              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 7</span>
<a name="l02325"></a>02325              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 8</span>
<a name="l02326"></a>02326              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// 9</span>
<a name="l02327"></a>02327              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// A</span>
<a name="l02328"></a>02328              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// B</span>
<a name="l02329"></a>02329              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// C</span>
<a name="l02330"></a>02330              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// D</span>
<a name="l02331"></a>02331              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  <span class="comment">// E</span>
<a name="l02332"></a>02332              0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0   <span class="comment">// F</span>
<a name="l02333"></a>02333         };
<a name="l02334"></a>02334 
<a name="l02335"></a>02335         <span class="comment">// Node name (anything but space \n \r \t / &gt; ? \0)</span>
<a name="l02336"></a>02336         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02337"></a>02337         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_node_name[256] = 
<a name="l02338"></a>02338         {
<a name="l02339"></a>02339           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02340"></a>02340              0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  <span class="comment">// 0</span>
<a name="l02341"></a>02341              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02342"></a>02342              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  <span class="comment">// 2</span>
<a name="l02343"></a>02343              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  <span class="comment">// 3</span>
<a name="l02344"></a>02344              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02345"></a>02345              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02346"></a>02346              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02347"></a>02347              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02348"></a>02348              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02349"></a>02349              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02350"></a>02350              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02351"></a>02351              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02352"></a>02352              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02353"></a>02353              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02354"></a>02354              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02355"></a>02355              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02356"></a>02356         };
<a name="l02357"></a>02357 
<a name="l02358"></a>02358         <span class="comment">// Text (i.e. PCDATA) (anything but &lt; \0)</span>
<a name="l02359"></a>02359         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02360"></a>02360         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_text[256] = 
<a name="l02361"></a>02361         {
<a name="l02362"></a>02362           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02363"></a>02363              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02364"></a>02364              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02365"></a>02365              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02366"></a>02366              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02367"></a>02367              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02368"></a>02368              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02369"></a>02369              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02370"></a>02370              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02371"></a>02371              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02372"></a>02372              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02373"></a>02373              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02374"></a>02374              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02375"></a>02375              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02376"></a>02376              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02377"></a>02377              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02378"></a>02378              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02379"></a>02379         };
<a name="l02380"></a>02380 
<a name="l02381"></a>02381         <span class="comment">// Text (i.e. PCDATA) that does not require processing when ws normalization is disabled </span>
<a name="l02382"></a>02382         <span class="comment">// (anything but &lt; \0 &amp;)</span>
<a name="l02383"></a>02383         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02384"></a>02384         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_text_pure_no_ws[256] = 
<a name="l02385"></a>02385         {
<a name="l02386"></a>02386           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02387"></a>02387              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02388"></a>02388              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02389"></a>02389              1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02390"></a>02390              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02391"></a>02391              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02392"></a>02392              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02393"></a>02393              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02394"></a>02394              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02395"></a>02395              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02396"></a>02396              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02397"></a>02397              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02398"></a>02398              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02399"></a>02399              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02400"></a>02400              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02401"></a>02401              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02402"></a>02402              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02403"></a>02403         };
<a name="l02404"></a>02404 
<a name="l02405"></a>02405         <span class="comment">// Text (i.e. PCDATA) that does not require processing when ws normalizationis is enabled</span>
<a name="l02406"></a>02406         <span class="comment">// (anything but &lt; \0 &amp; space \n \r \t)</span>
<a name="l02407"></a>02407         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02408"></a>02408         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_text_pure_with_ws[256] = 
<a name="l02409"></a>02409         {
<a name="l02410"></a>02410           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02411"></a>02411              0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  <span class="comment">// 0</span>
<a name="l02412"></a>02412              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02413"></a>02413              0,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02414"></a>02414              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02415"></a>02415              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02416"></a>02416              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02417"></a>02417              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02418"></a>02418              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02419"></a>02419              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02420"></a>02420              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02421"></a>02421              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02422"></a>02422              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02423"></a>02423              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02424"></a>02424              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02425"></a>02425              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02426"></a>02426              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02427"></a>02427         };
<a name="l02428"></a>02428 
<a name="l02429"></a>02429         <span class="comment">// Attribute name (anything but space \n \r \t / &lt; &gt; = ? ! \0)</span>
<a name="l02430"></a>02430         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02431"></a>02431         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_attribute_name[256] = 
<a name="l02432"></a>02432         {
<a name="l02433"></a>02433           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02434"></a>02434              0,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  0,  1,  1,  <span class="comment">// 0</span>
<a name="l02435"></a>02435              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02436"></a>02436              0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  <span class="comment">// 2</span>
<a name="l02437"></a>02437              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  0,  0,  0,  <span class="comment">// 3</span>
<a name="l02438"></a>02438              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02439"></a>02439              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02440"></a>02440              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02441"></a>02441              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02442"></a>02442              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02443"></a>02443              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02444"></a>02444              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02445"></a>02445              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02446"></a>02446              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02447"></a>02447              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02448"></a>02448              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02449"></a>02449              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02450"></a>02450         };
<a name="l02451"></a>02451 
<a name="l02452"></a>02452         <span class="comment">// Attribute data with single quote (anything but &#39; \0)</span>
<a name="l02453"></a>02453         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02454"></a>02454         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_attribute_data_1[256] = 
<a name="l02455"></a>02455         {
<a name="l02456"></a>02456           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02457"></a>02457              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02458"></a>02458              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02459"></a>02459              1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02460"></a>02460              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02461"></a>02461              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02462"></a>02462              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02463"></a>02463              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02464"></a>02464              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02465"></a>02465              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02466"></a>02466              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02467"></a>02467              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02468"></a>02468              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02469"></a>02469              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02470"></a>02470              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02471"></a>02471              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02472"></a>02472              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02473"></a>02473         };
<a name="l02474"></a>02474 
<a name="l02475"></a>02475         <span class="comment">// Attribute data with single quote that does not require processing (anything but &#39; \0 &amp;)</span>
<a name="l02476"></a>02476         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02477"></a>02477         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_attribute_data_1_pure[256] = 
<a name="l02478"></a>02478         {
<a name="l02479"></a>02479           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02480"></a>02480              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02481"></a>02481              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02482"></a>02482              1,  1,  1,  1,  1,  1,  0,  0,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02483"></a>02483              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02484"></a>02484              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02485"></a>02485              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02486"></a>02486              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02487"></a>02487              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02488"></a>02488              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02489"></a>02489              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02490"></a>02490              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02491"></a>02491              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02492"></a>02492              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02493"></a>02493              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02494"></a>02494              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02495"></a>02495              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02496"></a>02496         };
<a name="l02497"></a>02497 
<a name="l02498"></a>02498         <span class="comment">// Attribute data with double quote (anything but &quot; \0)</span>
<a name="l02499"></a>02499         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02500"></a>02500         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_attribute_data_2[256] = 
<a name="l02501"></a>02501         {
<a name="l02502"></a>02502           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02503"></a>02503              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02504"></a>02504              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02505"></a>02505              1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02506"></a>02506              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02507"></a>02507              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02508"></a>02508              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02509"></a>02509              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02510"></a>02510              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02511"></a>02511              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02512"></a>02512              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02513"></a>02513              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02514"></a>02514              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02515"></a>02515              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02516"></a>02516              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02517"></a>02517              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02518"></a>02518              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02519"></a>02519         };
<a name="l02520"></a>02520 
<a name="l02521"></a>02521         <span class="comment">// Attribute data with double quote that does not require processing (anything but &quot; \0 &amp;)</span>
<a name="l02522"></a>02522         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02523"></a>02523         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_attribute_data_2_pure[256] = 
<a name="l02524"></a>02524         {
<a name="l02525"></a>02525           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02526"></a>02526              0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 0</span>
<a name="l02527"></a>02527              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 1</span>
<a name="l02528"></a>02528              1,  1,  0,  1,  1,  1,  0,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 2</span>
<a name="l02529"></a>02529              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 3</span>
<a name="l02530"></a>02530              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 4</span>
<a name="l02531"></a>02531              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 5</span>
<a name="l02532"></a>02532              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 6</span>
<a name="l02533"></a>02533              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 7</span>
<a name="l02534"></a>02534              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 8</span>
<a name="l02535"></a>02535              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// 9</span>
<a name="l02536"></a>02536              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// A</span>
<a name="l02537"></a>02537              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// B</span>
<a name="l02538"></a>02538              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// C</span>
<a name="l02539"></a>02539              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// D</span>
<a name="l02540"></a>02540              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  <span class="comment">// E</span>
<a name="l02541"></a>02541              1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1   <span class="comment">// F</span>
<a name="l02542"></a>02542         };
<a name="l02543"></a>02543 
<a name="l02544"></a>02544         <span class="comment">// Digits (dec and hex, 255 denotes end of numeric character reference)</span>
<a name="l02545"></a>02545         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02546"></a>02546         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_digits[256] = 
<a name="l02547"></a>02547         {
<a name="l02548"></a>02548           <span class="comment">// 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F</span>
<a name="l02549"></a>02549            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 0</span>
<a name="l02550"></a>02550            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 1</span>
<a name="l02551"></a>02551            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 2</span>
<a name="l02552"></a>02552              0,  1,  2,  3,  4,  5,  6,  7,  8,  9,255,255,255,255,255,255,  <span class="comment">// 3</span>
<a name="l02553"></a>02553            255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  <span class="comment">// 4</span>
<a name="l02554"></a>02554            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 5</span>
<a name="l02555"></a>02555            255, 10, 11, 12, 13, 14, 15,255,255,255,255,255,255,255,255,255,  <span class="comment">// 6</span>
<a name="l02556"></a>02556            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 7</span>
<a name="l02557"></a>02557            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 8</span>
<a name="l02558"></a>02558            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// 9</span>
<a name="l02559"></a>02559            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// A</span>
<a name="l02560"></a>02560            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// B</span>
<a name="l02561"></a>02561            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// C</span>
<a name="l02562"></a>02562            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// D</span>
<a name="l02563"></a>02563            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  <span class="comment">// E</span>
<a name="l02564"></a>02564            255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255   <span class="comment">// F</span>
<a name="l02565"></a>02565         };
<a name="l02566"></a>02566     
<a name="l02567"></a>02567         <span class="comment">// Upper case conversion</span>
<a name="l02568"></a>02568         <span class="keyword">template</span>&lt;<span class="keywordtype">int</span> Dummy&gt;
<a name="l02569"></a>02569         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> lookup_tables&lt;Dummy&gt;::lookup_upcase[256] = 
<a name="l02570"></a>02570         {
<a name="l02571"></a>02571           <span class="comment">// 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  A   B   C   D   E   F</span>
<a name="l02572"></a>02572            0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13, 14, 15,   <span class="comment">// 0</span>
<a name="l02573"></a>02573            16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,   <span class="comment">// 1</span>
<a name="l02574"></a>02574            32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,   <span class="comment">// 2</span>
<a name="l02575"></a>02575            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,   <span class="comment">// 3</span>
<a name="l02576"></a>02576            64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   <span class="comment">// 4</span>
<a name="l02577"></a>02577            80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,   <span class="comment">// 5</span>
<a name="l02578"></a>02578            96, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,   <span class="comment">// 6</span>
<a name="l02579"></a>02579            80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 123,124,125,126,127,  <span class="comment">// 7</span>
<a name="l02580"></a>02580            128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,  <span class="comment">// 8</span>
<a name="l02581"></a>02581            144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,  <span class="comment">// 9</span>
<a name="l02582"></a>02582            160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,  <span class="comment">// A</span>
<a name="l02583"></a>02583            176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,  <span class="comment">// B</span>
<a name="l02584"></a>02584            192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,  <span class="comment">// C</span>
<a name="l02585"></a>02585            208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,  <span class="comment">// D</span>
<a name="l02586"></a>02586            224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,  <span class="comment">// E</span>
<a name="l02587"></a>02587            240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255   <span class="comment">// F</span>
<a name="l02588"></a>02588         };
<a name="l02589"></a>02589     }
<a name="l02591"></a>02591 
<a name="l02592"></a>02592 }
<a name="l02593"></a>02593 
<a name="l02594"></a>02594 <span class="comment">// Undefine internal macros</span>
<a name="l02595"></a>02595 <span class="preprocessor">#undef RAPIDXML_PARSE_ERROR</span>
<a name="l02596"></a>02596 <span class="preprocessor"></span>
<a name="l02597"></a>02597 <span class="comment">// On MSVC, restore warnings state</span>
<a name="l02598"></a>02598 <span class="preprocessor">#ifdef _MSC_VER</span>
<a name="l02599"></a>02599 <span class="preprocessor"></span><span class="preprocessor">    #pragma warning(pop)</span>
<a name="l02600"></a>02600 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02601"></a>02601 <span class="preprocessor"></span>
<a name="l02602"></a>02602 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Mar 19 2012 14:06:07 for FVLib by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
