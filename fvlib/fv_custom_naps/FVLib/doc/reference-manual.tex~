\documentclass[12pt]{book}
\usepackage{amssymb,amsmath}
\usepackage[dvips]{graphicx}
\usepackage[svgnames]{xcolor}
\usepackage{framed} 
\usepackage{makeidx}
\usepackage{hyperref,listings}
\usepackage{pstricks,pst-grad}
\usepackage[amsmath,thmmarks,framed]{ntheorem}
%
\parindent=0.0 truecm
\parskip=0.3truecm
\textheight 24cm    \textwidth 15cm
\voffset=-2.0cm       
\hoffset=-1.3cm


\usepackage[OT1]{fontenc}
\newfont{\headline}{cmbxsl14}
\newfont{\introfonta}{cmtt12 scaled 5000}
\newfont{\introfontb}{cmtt12 scaled 3000}
%\definecolor{gray}{rgb}{0.9,0.9,0.9} 
%\definecolor{lightgray}{rgb}{0.95,0.95,0.95} 
\newcommand{\Index}[0]{{\bf \sl{\color{DodgerBlue} Back to index}}}
\newcommand{\Format}[1]{{\bf \sl{\color{Olive} #1}}}
\newcommand{\Class}[1]{{\bf \tt{\color{magenta} #1}}}
\newcommand{\Method}[1]{{\bf \tt{\color{blue} #1}}}
\newcommand{\Field}[1]{{\bf \tt{\color{red} #1}}}
\newcommand{\Parameter}[1]{{\bf \tt {\color{red} #1}}}
\newcommand{\Function}[1]{{\bf \tt {\color{blue} #1}}}
\newcommand{\File}[1]{{\bf \tt{\color{green} #1}}}
\newcommand{\MyBox}[1]{\fcolorbox{black}{PeachPuff}{\tt #1} }
\newcommand{\FVlib}{{\bf FVlib}}
\newcommand{\gmsh}{{\bf Gmsh}}
{
      \theoremstyle{break}
      \theorembodyfont{\normalfont\itshape}
      \theoremheaderfont{\large\scshape\bfseries}
      \theoremindent 0pt
      %\theoremprework{\vskip 5pt\hrule\vskip 5pt }
      %\theorempostwork{\vskip -2pt\hrule}
      %\renewcommand \FrameCommand{{\color{blue}\vrule width 5pt \hspace{10pt}}}
      %\shadecolor{gris}
      \def\theoremframecommand{%
               \psshadowbox[fillstyle=solid,fillcolor=Seashell,linecolor=black]}%
       \newshadedtheorem{Description}{Short description}
     % \newtheorem{Description}{Description}[section]
}

\title{FVLib Reference manual}


\begin{document}
\thispagestyle{empty}
\setlength{\unitlength}{1.cm}
\setlength{\footskip}{0.cm}
\definecolor{colortitre}{rgb}{0.2,0.0,0.3}
\begin{picture}(15,23)
\put(1,22){\introfontb \textcolor{colortitre}{St\'ephane Clain}}
\put(6.2,12){\introfonta \textcolor{colortitre}{FVLib}}
\put(1.2,9){\introfontb  \textcolor{colortitre}{The Finite Volume Library}}  
\put(4,7.5){\introfontb  \textcolor{colortitre}{Reference Manual}}  
\end{picture}


\lstset{
        language=c++,showstringspaces=false,basicstyle=\footnotesize\tt,stringstyle=\color{red},
        keywordstyle=\color{black}\bf\small,numbers=left,numberstyle=\tiny,
        emph={FVCell1D,FVCell2D,FVCell3D,FVEdge2D,FVEdge3D,FVFace3D,Gmsh,FVMesh1D,FVMesh2D,FVMesh3D,
              FVVertex1D,FVVertex2D,FVVertex3D,FVDenseM,FVSparseM,FVVect,FVio,
              FVPoint1D,FVPoint2D,FVPoint3D,FVPoint4D,
              FVStencil,FVRecons1D,FVRecons2D,FVRecons3D,
              Parameter,Table,XML}, emphstyle=\color{magenta}
       }

\part{The basic layer}
\section*{Index for the basic layer}\label{MainIndex}

\begin{itemize}
\item \hyperref[MeshFormat]{\Format{mesh file format}}
\item \hyperref[VectorFormat]{\Format{vector file format}}
\item \hyperref[ParameterFormat]{\Format{parameter file format}}
\item \hyperref[TableFormat]{\Format{table file format}}
\end{itemize}

\begin{itemize}
\item \hyperref[FVCell1D]{\Class{FVCell1D}},
 \hyperref[FVCell2D]{\Class{FVCell2D}}, \hyperref[FVCell3D]{\Class{FVCell3D}},
\item \hyperref[FVEdge2D]{\Class{FVEdge2D}} , \hyperref[FVEdge3D]{\Class{FVEdge3D}},
\item \hyperref[FVFace3D]{\Class{FVFace3D}},
\item \hyperref[FVMesh1D]{\Class{FVMesh1D}}, \hyperref[FVMesh2D]{\Class{FVMesh2D}},
\hyperref[FVMesh3D]{\Class{FVMesh3D}},
\item \hyperref[FVStencil]{\Class{FVStencil}}, \hyperref[FVRecons1D]{\Class{FVRecons1D}},
 \hyperref[FVRecons2D]{\Class{FVRecons2D}}, \hyperref[FVRecons3D]{\Class{FVRecons3D}},
\item \hyperref[FVVertex1D]{\Class{FVVertex1D}}, \hyperref[FVVertex2D]{\Class{FVVertex2D}},
 \hyperref[FVVertex3D]{\Class{FVVertex3D}}
\item \hyperref[GMElement]{\Class{GMElement}}, \hyperref[Gmsh]{\Class{Gmsh}},
\end{itemize}

\begin{itemize}
\item \hyperref[FVDenseM]{\Class{FVDenseM}}, \hyperref[FVSparseM]{\Class{FVSparseM}},
\hyperref[FVVect]{\Class{FVVect}}
\end{itemize}

\begin{itemize}
\item \hyperref[FVGaussPoint1D]{\Class{FVGaussPoint1D}},
\hyperref[FVGaussPoint2D]{\Class{FVGaussPoint2D}},
\hyperref[FVGaussPoint3D]{\Class{FVGaussPoint3D}}
\item \hyperref[FVio]{\Class{FVio}}
\item \hyperref[FVPoint1D]{\Class{FVPoint1D}}, \hyperref[FVPoint2D]{\Class{FVPoint2D}}, 
\hyperref[FVPoint3D]{\Class{FVPoint3D}},  \hyperref[FVPoint4D]{\Class{FVPoint4D}}
\item \hyperref[Parameter]{\Class{Parameter}}, \hyperref[Table]{\Class{Table}}
\end{itemize}
\chapter{File format}
\newpage
\section{The mesh file format}\label{MeshFormat}
\begin{Description*}
The \FVlib\ \Format{mesh file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
{\headline 1D mesh.}\\[5pt]
\lstinputlisting[language=xml,caption=One dimensional mesh file format]{data/mesh1D.xml}
{\headline 2D mesh.}\\[5pt]
\lstinputlisting[language=xml,caption=Two dimensional mesh file format]{data/mesh2D.xml}
{\headline 3D mesh.}\\[5pt]
\lstinputlisting[language=xml,caption=Three dimensional mesh file format]{data/mesh3D.xml}
{\headline Example.}
\newpage
\section{The vector file format}\label{VectorFormat}
\begin{Description*}
The \FVlib\ \Format{vector file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
\lstinputlisting[language=xml,caption=vector file format]{data/vector.xml}
{\headline Example.}
\newpage
\section{The parameter file format}\label{ParameterFormat}
\begin{Description*}
The \FVlib\ \Format{parameter file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
\lstinputlisting[language=xml,caption=parameter file format]{data/parameter.xml}

{\headline Example.}
\newpage
\section{The table file format} \label{TableFormat}
\begin{Description*}
The \FVlib\ \Format{table file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
\lstinputlisting[language=xml,caption=table file format]{data/table.xml}
{\headline Example.}
\newpage
\chapter{Mesh}
\newpage
%
%===================== CLASS ================
%
\section{FVCell1D}\label{FVCell1D}
\centerline{\Class{FVCell1D} Class Reference}
\begin{Description*}
Class for the one-dimensional cell.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the cell.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the cell. \\[5pt]
\MyBox{double \Field{length} }\\[4pt]
The length of the cell. \\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>}   \Field{centroid} } \\[4pt]
The $x$-coordinate of the cell centroid.\\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>}  \Field{first\_normal},\Field{second\_normal}}\\[4pt]
Outward normal direction  at the first and second interface\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} *\Field{firstVertex},*\Field{secondVertex}}\\[4pt] 
Pointer to the first and second vertex of the cell.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVCell1D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVCell1D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first vertex of the cell and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{void  \Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the two vertices code.

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVCell1D} *\Parameter{c1}, \Class{FVCell1D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{c1} and \Parameter{c2} have the same vertices.

{\headline Example.}\\[5pt]
\newpage
%
%===================== CLASS ================
%
\section{FVCell2D}\label{FVCell2D}
\centerline{\Class{FVCell2D} Class Reference}

\begin{Description}
Class for the two-dimensional cell.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the cell.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the cell. \\[5pt]
\MyBox{double \Field{perimeter} }\\[4pt]
The perimeter of the cell.\\[5pt] 
\MyBox{double \Field{area} }\\[4pt]
The area of the cell. \\[5pt]
\MyBox{size\_t \Field{nb\_vertex} }\\[4pt]
The number of vertices of the cell. \\[5pt]
\MyBox{size\_t \Field{nb\_edge} }\\[4pt] 
The number of edges of the cell. \\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>}  \Field{centroid} } \\[4pt]
The $(x,y)$-coordinates of the cell centroid.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Field{vertex}[NB\_VERTEX\_PER\_CELL\_2D] } \\[4pt]
Pointer table to the vertices of the cell from 0 to \Field{nb\_vertex}-1. NB\_VERTEX\_PER\_CELL\_2D is the maximum
number of vertices in a cell defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Field{edge}[NB\_EDGE\_PER\_CELL\_2D] }\\[4pt] 
Pointer table to the edges of the cell from 0 to \Field{nb\_edge}-1. NB\_EDGE\_PER\_CELL\_2D is the maximum
number of edges in a cell defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\tt \hyperref[FVPoint2D]{ \Class{FVPoint2D}}<double>  \Field{cell2edge}[NB\_EDGE\_PER\_CELL\_2D] }\\[4pt]
Table of the cell--centroid edge--centroid  vector of the cell from 0 to \Field{nb\_edge}-1. 
NB\_EDGE\_PER\_CELL\_2D is the maximum number of edges in a cell defined in file 
\hyperref[FVLib_config]{\File{FVLib\_config.h}}.


{\headline Method.}\\[5pt]
\MyBox{\Method{FVCell2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVCell2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first  vertex of the cell and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{beginEdge}()}\\[4pt]
Initialize the internal pointer to the first edge of the cell and return the address.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{nextEdge}()}\\[4pt]
Return the pointer of the current edge and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> \Method{getCell2Edge}()}\\[4pt]
Return the cell-centroid to edge-centroid vector of the current edge handled by \Method{beginEdge} and
\Method{nextEdge}.\\[5pt]
\MyBox{\Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the vertices.\\[5pt]
\MyBox{\Method{setCode2Edge}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the edges.

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVCell2D} *\Parameter{c1}, \Class{FVCell2D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same edges.

{\headline Example.}\\[5pt]
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the edges of a 2D cell]
FVEdge2D *ptr_e;
FVCell2D c;
for(c.beginEdge();(ptr_e=c.nextEdge());)
    {
    cout<<"label of edge "<<ptr_e->label<<endl;
    cout<<"vector cell-centroid edge-centroid"<<c.getCell2Edge()<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 2D cell]
FVVertex2D *ptr_v;
FVCell2D c;
for(c.beginVertex();(ptr_v=c.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{FVCell3D}\label{FVCell3D}
\centerline{\Class{FVCell3D} Class Reference}

\begin{Description}
Class for the three-dimensional cell.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the cell.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the cell. \\[5pt]
\MyBox{double \Field{surface} }\\[4pt]
The surface of the cell.\\[5pt] 
\MyBox{double \Field{volume} }\\[4pt]
The volume of the cell. \\[5pt]
\MyBox{size\_t \Field{nb\_vertex} }\\[4pt]
The number of vertices of the cell. \\[5pt]
\MyBox{size\_t \Field{nb\_face} }\\[4pt] 
The number of faces of the cell. \\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>}  \Field{centroid} } \\[4pt]
The $(x,y,z)$-coordinates of the cell centroid.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Field{vertex}[NB\_VERTEX\_PER\_CELL\_3D] } \\[4pt]
Pointer table to the vertices of the cell from 0 to \Field{nb\_vertex}-1. NB\_VERTEX\_PER\_CELL\_3D is the maximum
number of vertices in a cell defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFACE3D}} * \Field{face}[NB\_FACE\_PER\_CELL\_3D] }\\[4pt] 
Pointer table to the faces of the cell from 0 to \Field{nb\_face}-1. NB\_FACE\_PER\_CELL\_3D is the maximum
number of edges in a cell defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\tt \hyperref[FVPoint3D]{ \Class{FVPoint3D}}<double>  \Field{cell2face}[NB\_FACE\_PER\_CELL\_3D] }\\[4pt]
Table of the cell--centroid face--centroid  vector of the cell from 0 to \Field{nb\_face}-1. 
NB\_FACE\_PER\_CELL\_3D is the maximum number of edges in a cell defined in file 
\hyperref[FVLib_config]{\File{FVLib\_config.h}}.


{\headline Method.}\\[5pt]
\MyBox{\Method{FVCell3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVCell3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first  vertex of the cell and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{beginFace}()}\\[4pt]
Initialize the internal pointer to the first face of the cell and return the address.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{nextFace}()}\\[4pt]
Return the pointer of the current face and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> \Method{getCell2Face}()}\\[4pt]
Return the cell-centroid to face-centroid vector of the current edge handled by \Method{beginFace} and
\Method{nextFace}.\\[5pt]
\MyBox{\Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the vertices.\\[5pt]
\MyBox{\Method{setCode2Edge}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the edges.\\[5pt]
\MyBox{\Method{setCode2Face}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the faces.

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVCell3D} *\Parameter{c1}, \Class{FVCell3D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same faces.

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the faces of a 3D cell]
FVFace3D *ptr_f;
FVCell3D c;
for(c.beginFace();(ptr_f=c.nextFace());)
    {
    cout<<"label of face "<<ptr_f->label<<endl;
    cout<<"vector cell-centroid face-centroid"<<c.getCell2Face()<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 3D cell]
FVVertex2D *ptr_v;
FVCell3D c;
for(c.beginVertex();(ptr_v=c.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\newpage

%
%===================== CLASS ================
%
\section{FVEdge2D}\label{FVEdge2D}
\centerline{\Class{FVEdge2D} Class Reference}

\begin{Description}
Class for the two-dimensional edge.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the edge.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the edge. \\[5pt]
\MyBox{double \Field{length} }\\[4pt]
The length of the edge. \\[5pt]
\MyBox{size\_t \Field{nb\_vertex} }\\[4pt]
The number of vertices of the edge (always $2$). \\[5pt]
\MyBox{size\_t \Field{nb\_cell} }\\[4pt] 
The number of cell of the edge (always $2$). \\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>}  \Field{centroid} } \\[4pt]
The $(x,y)$-coordinates of the edge centroid.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} *\Field{firstVertex},*\Field{secondVertex}}\\[4pt] 
Pointer to the first and second vertex of the edge.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} *\Field{leftCell},*\Field{rightCell}}\\[4pt] 
Pointer to the left and right cell of the edge. \Field{leftCell} is always the inner cell.
\Field{rightCell}{\tt =NULL} if the edge is on the boundary.\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>}  \Field{normal} } \\[4pt]
The $(x,y)$-coordinate of the edge normal vector from left to right.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVEdge2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVEdge2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the vertices.\\[5pt]

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVEdge2D} *\Parameter{c1}, \Class{FVEdge2D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same vertices.

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVEdge3D}\label{FVEdge3D}
\centerline{\Class{FVEdge3D} Class Reference}

\begin{Description}
Class for the three-dimensional edge.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the edge.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the edge. \\[5pt]
\MyBox{double \Field{length} }\\[4pt]
The length of the edge. \\[5pt]
\MyBox{size\_t \Field{nb\_vertex} }\\[4pt]
The number of vertices of the edge (always $2$). \\[5pt]
\MyBox{size\_t \Field{nb\_cell} }\\[4pt] 
The number of cell of the edge (always $2$). \\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>}  \Field{centroid} } \\[4pt]
The $(x,y,z)$-coordinates of the edge centroid.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} *\Field{firstVertex},*\Field{secondVertex}}\\[4pt] 
Pointer to the first and second vertex of the edge.\\[5pt]


{\headline Method.}\\[5pt]
\MyBox{\Method{FVCell3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVCell3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the vertices.\\[5pt]

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVEdge3D} *\Parameter{c1}, \Class{FVEdge3D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same vertices.

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVFace3D}\label{FVFace3D}
\centerline{\Class{FVFace3D} Class Reference}

\begin{Description}
Class for the three-dimensional face.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the face.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the face. \\[5pt]
\MyBox{double \Field{perimeter} }\\[4pt]
The perimeter of the face. \\[5pt]
\MyBox{double \Field{area} }\\[4pt]
The area of the face. \\[5pt]
\MyBox{size\_t \Field{nb\_vertex} }\\[4pt]
The number of vertices of the edge (always greater than $3$). \\[5pt]
\MyBox{size\_t \Field{nb\_cell} }\\[4pt] 
The number of cell of the edge (always greater than $3$). \\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>}  \Field{centroid} } \\[4pt]
The $(x,y,z)$-coordinate of the face centroid.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} *\Field{leftCell},*\Field{rightCell}}\\[4pt] 
Pointer to the left and right cell of the edge. \Field{leftCell} is always the inner cell.
\Field{rightCell}{\tt =NULL} if the edge is on the boundary.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} *\Field{vertex}[NB\_VERTEX\_PER\_FACE\_3D]}\\[4pt] 
Pointer table to the vertices of the face from 0 to \Field{nb\_vertex}-1. NB\_VERTEX\_PER\_FACE\_3D is the maximum
number of vertices in a face defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVVEdge3D}} *\Field{edge}[NB\_EDGE\_PER\_FACE\_3D]}\\[4pt] 
Pointer table to the edges of the face from 0 to \Field{nb\_edge}-1. NB\_EDGE\_PER\_FACE\_3D is the maximum
number of edges in a face defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>}  \Field{normal}[NB\_EDGE\_PER\_FACE\_3D] } \\[4pt]
The $(x,y,z)$-coordinates of the normal vector from left to right of a subtriangle $i$
defined by the \Field{edge}[i] and the centroid of the face with $i$ from 0 to \Field{nb\_edge}-1..\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVFace3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVFace3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first vertex of the face and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVEdge3D}} * \Method{beginEdge}()}\\[4pt]
Initialize the internal pointer to the first edge of the face and return the address.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVEdge3D}} * \Method{nextEdge}()}\\[4pt]
Return the pointer of the current edge and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> \Method{getNormal}()}\\[4pt]
Return the outward normal vector of the subtriangle defined by the face centroid and the 
current edge handled by \Method{beginEdge} and \Method{nextEdge}.\\[5pt]



\MyBox{\Method{setCode2Vertex}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the vertices.\\[5pt]
\MyBox{\Method{setCode2Edge}(size\_t \Parameter{val=0)}}\\[4pt]
Set \Parameter{val} (0 default value) to the code of the edges.\\[5pt]

{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVFace3D} *\Parameter{c1}, \Class{FVFace3D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same vertices.

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the edges of a 3D face]
FVEdge3D *ptr_e;
FVFace3D f;
for(f.beginEdge();(ptr_e=f.nextEdge());)
    {
    cout<<"label of edge "<<ptr_e->label<<endl;
    cout<<"outwer normal vector  face-centroid - edge"<<f.getNormal()<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 3D face]
FVVertex2D *ptr_v;
FVFace3D f;
for(f.beginVertex();(ptr_v=f.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\newpage

%
%===================== CLASS ================
%
\section{FVMesh1D}\label{FVMesh1D}
\centerline{\Class{FVMesh1D} Class Reference}
\begin{Description*}
Class for the one-dimensional mesh.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVMesh1D}()}\\[4pt]
Default Constructor method.\\[5pt]
\MyBox{\Method{FVMesh1D}(const char * \Parameter{filename})}\\[4pt]
Constructor method which load the \hyperref[MeshFormat]{\FVlib} format mesh  in file \Parameter{filename}.\\[5pt]
\MyBox{void \Method{read}(const char * \Parameter{filename})}\\[4pt]
Load the \hyperref[MeshFormat]{\FVlib} format mesh in file \Parameter{filename}.\\[5pt] 
\MyBox{void \Method{write}(const char * \Parameter{filename})}\\[4pt]
Write the current mesh on disk with the \hyperref[MeshFormat]{\FVlib} format in file \Parameter{filename}.\\[5pt]
\MyBox{string \Method{getName}()}\\[4pt]
Return the name of the mesh. Void string if no name is defined.\\[5pt]
\MyBox{void \Method{setName}(const char * name)}\\[4pt]     
Set the name of the mesh.\\[5pt] 
\MyBox{size\_t \Method{getNbVertex}()}\\[4pt]
Return the number of vertices of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbCell}()}\\[4pt]
Return the number of cells of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{getVertex}(size\_t \Parameter{i})}\\[4pt]
Return the address of vertex \Parameter{i}, from 0 to \Method{getNbVertex}-1.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1}} * \Method{beginBoundaryVertex}()}.\\[4pt]
Initialize the internal pointer to the first vertex of the mesh which is on the boundary of the domain. 
Return the address. An edge on the boundary has a {\tt NULL} pointer for the \Field{rigthCell}.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{nextBoundaryVertex}()}\\[4pt]
Return the pointer of the current vertex on the boundary and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVCell1D]{\Class{FVCell1D}} * \Method{getCell}(size\_t \Parameter{i})}\\[4pt]
Return the address of cell \Parameter{i}, from 0 to \Method{getNbCell}-1.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first  vertex of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex1D]{\Class{FVVertex1D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVCell1D]{\Class{FVCell1D}} * \Method{beginCell}()}\\[4pt]
Initialize the internal pointer to the first cell of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVCell1D]{\Class{FVCell1D}} * \Method{nextCell}()}\\[4pt]
Return the pointer of the current cell and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{void \Method{msh2FVMesh}(\hyperref[Gmsh]{\Class{Gmsh}} \&mg) * }\\[4pt]
Convert a \hyperref[Gmsh]{\Class{Gmsh}} into a \Class{FVMesh1D} format.

{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 1D mesh]
FVMesh1D("my_mesh_1D");
FVVertex1D *ptr_v;
for(m.beginVertex();(ptr_v=m.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the cells of a 1D mesh]
FVMesh1D("my_mesh_1D");
FVCell1D *ptr_c;
for(m.beginCell();(ptr_c=m.nextCell());)
    {
    cout<<"label of cell "<<ptr_c->label<<endl;
    cout<<"length of the cell "<<ptr_c->length<<endl;
    }
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{FVMesh2D}\label{FVMesh2D}
\centerline{\Class{\tt FVMesh2D} Class Reference}
\begin{Description*}
Class for the two-dimensional mesh.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVMesh2D}()}\\[4pt]
Default Constructor method.\\[5pt]
\MyBox{\Method{FVMesh2D}(const char * \Parameter{filename})}\\[4pt]
Constructor method which load the \hyperref[MeshFormat]{\FVlib} format mesh  in file \Parameter{filename}.\\[5pt]
\MyBox{void \Method{read}(const char * \Parameter{filename})}\\[4pt]
Load the \hyperref[MeshFormat]{\FVlib} format mesh in file \Parameter{filename}.\\[5pt] 
\MyBox{void \Method{write}(const char * \Parameter{filename})}\\[4pt]
Write the current mesh on disk with the \hyperref[MeshFormat]{\FVlib} format in file \Parameter{filename}.\\[5pt] 
\MyBox{string \Method{getName}()}.\\[4pt]
Return the name of the mesh. Void string if no name is defined.\\[5pt]
\MyBox{void \Method{setName}(const char * name)}\\[4pt]     
Set the name of the mesh.\\[5pt]
\MyBox{size\_t \Method{getNbVertex}()}.\\[4pt]
Return the number of vertices of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbEdge}()}.\\[4pt]
Return the number of edges of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbCell}()}.\\[4pt]
Return the number of cells of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Method{getVertex}(size\_t \Parameter{i})}.\\[4pt]
Return the address of vertex \Parameter{i}, from 0 to \Method{getNbVertex}-1.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{getEdge}(size\_t \Parameter{i})}.\\[4pt]
Return the address of edge \Parameter{i}, from 0 to \Method{getNbEdge}-1.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} * \Method{getCell}(size\_t \Parameter{i})}.\\[4pt]
Return the address of cell \Parameter{i}, from 0 to \Method{getNbCell}-1.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Method{beginVertex}()}.\\[4pt]
Initialize the internal pointer to the first  vertex of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex2D]{\Class{FVVertex2D}} * \Method{nextVertex}()}.\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{beginEdge}()}.\\[4pt]
Initialize the internal pointer to the first edge of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{nextEdge}()}.\\[4pt]
Return the pointer of the current edge and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{beginBoundaryEdge}()}.\\[4pt]
Initialize the internal pointer to the first edge of the mesh which is on the boundary of the domain. 
Return the address. An edge on the boundary has a {\tt NULL} pointer for the \Field{rigthCell}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVEdge2D}} * \Method{nextBoundaryEdge}()}\\[4pt]
Return the pointer of the current edge on the boundary and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt] 
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} * \Method{beginCell}()}.\\[4pt]
Initialize the internal pointer to the first cell of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} * \Method{nextCell}()}.\\[4pt]
Return the pointer of the current cell and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{void \Method{msh2FVMesh}(\hyperref[Gmsh]{\Class{Gmsh}} \&mg) * }\\[4pt]
Convert a \hyperref[Gmsh]{\Class{Gmsh}} into a \Class{FVMesh2D} format.\\[5pt]
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 2D mesh]
FVMesh2D("my_mesh_2D");
FVVertex2D *ptr_v;
for(m.beginVertex();(ptr_v=m.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the edges of a 2D mesh]
FVMesh2D("my_mesh_2D");
FVEdge2D *ptr_e;
for(m.beginEdge();(ptr_e=m.nextEdge());)
    {
    cout<<"label of edge "<<ptr_e->label<<endl;
    cout<<"coordinate of the centroid "<<ptr_e->centroid<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the cells of a 2D mesh]
FVMesh2D("my_mesh_2D");
FVCell2D *ptr_c;
for(m.beginCell();(ptr_c=m.nextCell());)
    {
    cout<<"label of cell "<<ptr_c->label<<endl;
    cout<<"surface of the cell "<<ptr_c->area<<endl;
    }
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{FVMesh3D}\label{FVMesh3D}
\centerline{\Class{\tt FVMesh3D} Class Reference}
\begin{Description*}
Class for the three-dimensional mesh.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVMesh3D}()}\\[4pt]
Default Constructor method.\\[5pt]
\MyBox{\Method{FVMesh3D}(const char * \Parameter{filename})}\\[4pt]
Constructor method which load the \hyperref[MeshFormat]{\FVlib} format mesh  in file \Parameter{filename}.\\[5pt]
\MyBox{void \Method{read}(const char * \Parameter{filename})}\\[4pt]
Load the \hyperref[MeshFormat]{\FVlib} format mesh in file \Parameter{filename}.\\[5pt] 
\MyBox{void \Method{write}(const char * \Parameter{filename})}\\[4pt]
Write the current mesh on disk with the \hyperref[MeshFormat]{\FVlib} format in file \Parameter{filename}.\\[5pt] 
\MyBox{string \Method{getName}()}\\[4pt]
Return the name of the mesh. Void string if no name is defined.\\[5pt]
\MyBox{void \Method{setName}(const char * name)}\\[4pt]     
Set the name of the mesh.\\[5pt]
\MyBox{size\_t \Method{getNbVertex}()}\\[4pt]
Return the number of vertices of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbEdge}()}\\[4pt]
Return the number of edges of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbFace}()}\\[4pt]
Return the number of faces of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbCell}()}\\[4pt]
Return the number of cells of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{getVertex}(size\_t \Parameter{i})}\\[4pt]
Return the address of vertex \Parameter{i}, from 0 to \Method{getNbVertex}-1.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVEdge3D}} * \Method{getEdge}(size\_t \Parameter{i})}\\[4pt]
Return the address of edge \Parameter{i}, from 0 to \Method{getNbEdge}-1.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{getFace}(size\_t \Parameter{i})}\\[4pt]
Return the address of edge \Parameter{i}, from 0 to \Method{getNbEdge}-1.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} * \Method{getCell}(size\_t \Parameter{i})}\\[4pt]
Return the address of cell \Parameter{i}, from 0 to \Method{getNbCell}-1.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{beginVertex}()}\\[4pt]
Initialize the internal pointer to the first  vertex of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{nextVertex}()}\\[4pt]
Return the pointer of the current vertex and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVEdge3D}} * \Method{beginEdge}()}\\[4pt]
Initialize the internal pointer to the first edge of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVEdge3D]{\Class{FVEdge3D}} * \Method{nextEdge}()}\\[4pt]
Return the pointer of the current edge and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{beginFace}()}\\[4pt]
Initialize the internal pointer to the first face of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{nextFace}()}\\[4pt]
Return the pointer of the current edge and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{\hyperref[FVFace3D]{\Class{FVFace3D}} * \Method{beginBoundaryFace}()}\\[4pt]
Initialize the internal pointer to the first face of the mesh which is on the boundary of the domain. return the address. An edge on the boundary has a {\tt NULL} pointer for the \Field{rigthCell}.\\[5pt]
\MyBox{\hyperref[FVEdge2D]{\Class{FVFace3D}} * \Method{nextBoundaryFace}()}\\[4pt]
Return the pointer of the current face on the boundary and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt] 
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} * \Method{beginCell}()}\\[4pt]
Initialize the internal pointer to the first cell of the mesh and return the address.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} * \Method{nextCell}()}\\[4pt]
Return the pointer of the current cell and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
\MyBox{void \Method{msh2FVMesh}(\hyperref[Gmsh]{\Class{Gmsh}} \&mg) * }\\[4pt]
Convert a \hyperref[Gmsh]{\Class{Gmsh}} into a \Class{FVMesh3D} format.

{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the vertices of a 3D mesh]
FVMesh3D("my_mesh_3D");
FVVertex3D *ptr_v;
for(m.beginVertex();(ptr_v=m.nextVertex());)
    {
    cout<<"label of vertex "<<ptr_v->label<<endl;
    cout<<"coordinate of the vertex "<<ptr_v->coord<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the edges of a 3D mesh]
FVMesh3D("my_mesh_3D");
FVEdge3D *ptr_e;
for(m.beginEdge();(ptr_e=m.nextEdge());)
    {
    cout<<"label of edge "<<ptr_e->label<<endl;
    cout<<"coordinate of the centroid "<<ptr_e->centroid<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the faces of a 3D mesh]
FVMesh3D("my_mesh_3D");
FVFace3D *ptr_f;
for(m.beginFace();(ptr_f=m.nextFace());)
    {
    cout<<"label of face "<<ptr_f->label<<endl;
    cout<<"coordinate of the centroid "<<ptr_f->centroid<<endl;
    }
\end{lstlisting}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=Loop over the cells of a 3D mesh]
FVMesh3D("my_mesh_3D");
FVCell3D *ptr_c;
for(m.beginCell();(ptr_c=m.nextCell());)
    {
    cout<<"label of cell "<<ptr_c->label<<endl;
    cout<<"volume of the cell "<<ptr_c->volume<<endl;
    }
\end{lstlisting}

\newpage
%
%===================== CLASS ================
%
\section{FVStencil}\label{FVStencil}
\centerline{\Class{\tt FVStencil} Class Reference}
\begin{Description*}
Class to handle stencil.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
     
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{nb\_geometry} }\\[4pt]
Number of geometrical element is the stencil.\\[5pt]
\MyBox{void  *\Field{reference\_geometry} }\\[4pt]
Pointer to the geometrical entity of reference. \\[5pt]
\MyBox{size\_t   \Field{reference\_type;} } \\[4pt]
The type of the geometrical entity defined by the {\tt enum}.
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=enum type for the stencil]
enum EntityCode{
NULL_ENTITY=0, FVVERTEX1D,FVVERTEX2D, FVVERTEX3D,
FVCELL1D, FVCELL2D, FVCELL3D,
FVEDGE2D,FVEDGE3D,FVFACE3D,};
\end{lstlisting} 
\MyBox{void*   \Field{geometry[NB\_ENTITY\_PER\_STENCIL]} } \\[4pt]
Store the geometrical entities of the stencil {\tt NB\_ENTITY\_PER\_STENCIL} is defined in the file
\hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]
\MyBox{size\_t   \Field{type[NB\_ENTITY\_PER\_STENCIL]} } \\[4pt]
Store the geometrical entities type of the stencil {\tt NB\_ENTITY\_PER\_STENCIL} is defined in the file
\hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVStencil}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVStencil}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVStencil}(const \Class{FVStencil} \&)}\\[4pt]
Copy constructor method.\\[5pt]
\MyBox{void * \Method{beginGeometry}()}\\[4pt]
Initialize the internal pointer to the first geometrical entity of the stencil and return the address.\\[5pt]
\MyBox{void * \Method{nextGeometry}()}\\[4pt]
Return the pointer of the current geometrical entity and move to the next one. 
If we reach the end of the list, return {\tt NULL}.\\[5pt]
\MyBox{void * \Method{getGeometry}(size\_t \Parameter{i})}\\[4pt]
Return the pointer of the geometrical entity of index \Parameter{i}.\\[5pt]
\MyBox{void * \Method{getReferenceGeometry}()}\\[4pt]
Return the pointer of the geometrical entity of reference.\\[5pt]
\MyBox{size\_t \Method{getType}()}\\[4pt]
Return the type of the current geometrical entity.\\[5pt]
\MyBox{size\_t \Method{getType}(size\_t \Parameter{i})}\\[4pt]
Return the type of the geometrical entity of index \Parameter{i}.\\[5pt]
\MyBox{size\_t \Method{getReferenceType}()}\\[4pt]
Return the type of the Reference geometrical entity.\\[5pt]
\MyBox{size\_t \Method{getIndex}()}\\[4pt]
Retrun the index of the current geometrical identity.\\[5pt]
\MyBox{void \Method{clean}()}\\[4pt]
Clean the stencil. Reset all the variables to zero and pointer to NULL.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVVertex1D]{\Class{FVVertex1D}} *)}\\[4pt]
Add a \hyperref[FVVertex1D]{\Class{FVVertex1D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVVertex1D]{\Class{FVVertex1D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVVertex1D]{\Class{FVVertex1D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVVertex2D]{\Class{FVVertex2D}} *)}\\[4pt]
Add a \hyperref[FVVertex2D]{\Class{FVVertex2D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVVertex2D]{\Class{FVVertex2D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVVertex2D]{\Class{FVVertex2D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVVertex3D]{\Class{FVVertex3D}} *)}\\[4pt]
Add a \hyperref[FVVertex3D]{\Class{FVVertex3D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVVertex3D]{\Class{FVVertex3D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVVertex3D]{\Class{FVVertex3D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVEdge2D]{\Class{FVEdge2D}} *)}\\[4pt]
Add a \hyperref[FVEdge2D]{\Class{FVEdge2D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVEdge2D]{\Class{FVEdge2D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVEdge2D]{\Class{FVEdge2D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVEdge3D]{\Class{FVEdge3D}} *)}\\[4pt]
Add a \hyperref[FVEdge3D]{\Class{FVEdge3D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVEdge3D]{\Class{FVEdge3D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVEdge3D]{\Class{FVEdge3D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVFace3D]{\Class{FVFace3D}} *)}\\[4pt]
Add a \hyperref[FVFace3D]{\Class{FVFace3D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVFace3D]{\Class{FVFace3D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVFace3D]{\Class{FVFace3D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVCell1D]{\Class{FVCell1D}} *)}\\[4pt]
Add a \hyperref[FVCell1D]{\Class{FVCell1D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVCell1D]{\Class{FVCell1D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVCell1D]{\Class{FVCell1D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVCell2D]{\Class{FVCell2D}} *)}\\[4pt]
Add a \hyperref[FVCell2D]{\Class{FVCell2D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVCell2D]{\Class{FVCell2D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVCell2D]{\Class{FVCell2D}}.\\[5pt]
\MyBox{void \Method{addStencil}(\hyperref[FVCell3D]{\Class{FVCell3D}} *)}\\[4pt]
Add a \hyperref[FVCell3D]{\Class{FVCell3D}} element to the stencil.\\[5pt]    
\MyBox{void \Method{setReferenceGeometry}(\hyperref[FVCell3D]{\Class{FVCell3D}} *)}\\[4pt]
Set the reference geometrical entity as a \hyperref[FVCell3D]{\Class{FVCell3D}}.\\[5pt]  

{\headline Function.}\\[5pt]
No function for this class.

{\headline Example.}\\[5pt]
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=handle stencil for a 1D mesh]
FVMesh1D m;    
FVStencil st;
// read a mesh and set the reference geometrical entity
m.read("mesh1D.xml");
st.setReferenceGeometry(m.beginCell());
// gather geometrical entities in the stencil
st.addStencil(m.nextCell());
st.addStencil(m.beginVertex());
st.addStencil(m.nextCell());
st.addStencil(m.nextVertex());
\end{lstlisting} 
\newpage
%
%===================== CLASS ================
%







\section{FVRecons1D}\label{FVRecons1D}
\centerline{\Class{\tt FVRecons1D} Class Reference}
\begin{Description*}
Class to handle the polynomial reconstruction for 1D meshes.
\hfill \hyperref[MainIndex]{\Index}\\
{\sc Not available yet} 
\end{Description*}

{\headline Field.}\\[5pt]
No field is available in this class.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVRecons1D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVRecons1D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVRecons1D}(const \Class{FVRecons1D} \&)}\\[4pt]
Copy constructor method.\\[5pt]
\MyBox{\Method{FVRecons1D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
Constructor method. The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{\Method{FVRecons1D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Constructor method. Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil reference \Parameter{s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{clean}()}\\[4pt]
Clean the reconstruction. Empty the matrixes and the coefficients. 
After a \Method{clean}, the user can reuse the variable as a new one.\\[5pt]
\MyBox{void  \Method{setPolynomialDegree}({\tt size\_t} \Parameter{d})}\\[4pt]
Set the polynomial degree of the reconstruction.\\[5pt]
\MyBox{{\tt size\_t} \Method{getPolynomialDegree}()}\\[4pt]
Return the polynomial degree of the reconstruction.\\[5pt]
\MyBox{void  \Method{setReferencePoint}(\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} P)}\\[4pt]
Set the reference point for the polynomial reconstruction.\\[5pt] 
\MyBox{void  \Method{setVectorVertex1D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})}\\[4pt]
Give the data associated to the Vextexs of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorCell1D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u}) }\\[4pt]
Give the data associated to the Cells of the mesh.\\[5pt]
\MyBox{void  \Method{doConservativeMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function will respect
the mean value with respect to the Reference entity. Stencil must be provided with a reference entity
to use the method.\\[5pt]
\MyBox{void  \Method{computeConservativeCoef}()} \\[4pt]
Compute the coefficient of the conservative polynomial reconstruction. Method \Method{doConservativeMatrix} 
must have been executed once to compute the matrix associated to the vertex. Data must be provided via methods  \Method{setVectorVertex1D}  or \Method{setVectorCell1D} in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{void  \Method{doMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function is the 
interpolation of the values in the Least square meaning. Stencil must be provided to use the method but no reference
element is require. Reference Point is the Origin by default bu should be modified with \Method{setReferencePoint}.\\[5pt]
\MyBox{void  \Method{computeCoef}()} \\[4pt]
Compute the coefficient of the polynomial reconstruction. Method \Method{doMatrix} must have been executed once
to compute the matrix associated to the vertex. Data must be provided via methods  \Method{setVectorVertex1D}
 or \Method{setVectorCell1D} in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} getDerivative(\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial derivative at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} getDerivative(\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
{\headline Function.}\\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}}{\tt <size\_t>} \Function{alpha1D}({\tt size\_t} \Parameter{k})}\\[4pt]
Return the power $\alpha(k)=\alpha^1$ associated to the monomial $p(x_1)=(x_1)^{\alpha^1}$
where \Parameter{k} ranges between $0$ and $d-1$, with $d$ the degree of the polynomial reconstruction.
This function is the fundamental link between the powers and their storage in a vector.\\[5pt]



{\headline Example.}\\[5pt]
\newpage
%
%===================== CLASS ================
%
\section{FVRecons2D}\label{FVRecons2D}
\centerline{\Class{\tt FVRecons2D} Class Reference}
\begin{Description*}
Class to handle the polynomial reconstruction for 2D meshes.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
No field is available in this class.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVRecons2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVRecons2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVRecons2D}(const \Class{FVRecons2D} \&)}\\[4pt]
Copy constructor method.\\[5pt]
\MyBox{\Method{FVRecons2D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
Constructor method. The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{\Method{FVRecons2D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Constructor method. Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil reference \Parameter{s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{clean}()}\\[4pt]
Clean the reconstruction. Empty the matrixes and the coefficients. 
After a \Method{clean}, the user can reuse the variable as a new one.\\[5pt]
\MyBox{void  \Method{setPolynomialDegree}({\tt size\_t} \Parameter{d})}\\[4pt]
Set the polynomial degree of the reconstruction.\\[5pt]
\MyBox{{\tt size\_t} \Method{getPolynomialDegree}()}\\[4pt]
Return the polynomial degree of the reconstruction.\\[5pt]
\MyBox{void  \Method{setReferencePoint}(\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} P)}\\[4pt]
Set the reference point for the polynomial reconstruction.\\[5pt] 
\MyBox{void  \Method{setVectorVertex2D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})}\\[4pt]
Give the data associated to the Vextexs of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorEdge2D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})  }\\[4pt]
Give the data associated to the Edges of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorCell2D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u}) }\\[4pt]
Give the data associated to the Cells of the mesh.\\[5pt]
\MyBox{void  \Method{doConservativeMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function will respect
the mean value with respect to the Reference entity. Stencil must be provided with a reference entity
to use the method.\\[5pt]
\MyBox{void  \Method{computeConservativeCoef}()} \\[4pt]
Compute the coefficient of the conservative polynomial reconstruction. Method \Method{doConservativeMatrix} 
must have been executed once to compute the matrix associated to the vertex. Data must be provided via methods
\Method{setVectorVertex2D},  \Method{setVectorEdge2D} or \Method{setVectorCell12D} 
in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{void  \Method{doMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function is the 
interpolation of the values in the Least square meaning. Stencil must be provided to use the method but no reference
element is require. Reference Point is the Origin by default bu should be modified with \Method{setReferencePoint}.\\[5pt]
\MyBox{void  \Method{computeCoef}()} \\[4pt]
Compute the coefficient of the polynomial reconstruction. Method \Method{doMatrix} must have been executed once
to compute the matrix associated to the vertex. Data must be provided via methods  \Method{setVectorVertex2D},
 \Method{setVectorEdge2D} or \Method{setVectorCell2D} in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} getDerivative(\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial derivatives at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} getDerivative(\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
{\headline Function.}\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}}{\tt <size\_t>} \Function{alpha2D}({\tt size\_t} \Parameter{k})}\\[4pt]
Return the power $\alpha(k)=(\alpha^1,\alpha^2)$ associated to the monomial $p(x_1,x_2)=(x_1)^{\alpha^1}(x_2)^{\alpha^2}$
where \Parameter{k} ranges between $0$ and $d(d+1)/2-1$, with $d$ the degree of the polynomial reconstruction.
This function is the fundamental link between the powers and their storage in a vector.\\[5pt]
{\headline Example.}\\[5pt]
\newpage
%
%===================== CLASS ================
%
\section{FVRecons3D}\label{FVRecons3D}
\centerline{\Class{\tt FVRecons3D} Class Reference}
\begin{Description*}
Class to handle the polynomial reconstruction for 3D meshes.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
No field is available in this class.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVRecons3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVRecons3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVRecons3D}(const \Class{FVRecons3D} \&)}\\[4pt]
Copy constructor method.\\[5pt]
\MyBox{\Method{FVRecons3D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
Constructor method. The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{\Method{FVRecons3D}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Constructor method. Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil pointer \Parameter{ptr\_s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} *\Parameter{ptr\_s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s}, size\_t \Parameter{d})}\\[4pt]
The method gives the stencil reference \Parameter{s} and the degree
\Parameter{d} for the future polynomial reconstruction.\\[5pt]
\MyBox{void  \Method{setStencil}(\hyperref[FVStencil]{\Class{FVStencil}} \&\Parameter{s})}\\[4pt]
Same class as above but \Parameter{d} is assumed to be zero leading to a first-order 
reconstruction.\\[5pt]
\MyBox{void  \Method{clean}()}\\[4pt]
Clean the reconstruction. Empty the matrixes and the coefficients. 
After a \Method{clean}, the user can reuse the variable as a new one.\\[5pt]
\MyBox{void  \Method{setPolynomialDegree}({\tt size\_t} \Parameter{d})}\\[4pt]
Set the polynomial degree of the reconstruction.\\[5pt]
\MyBox{{\tt size\_t} \Method{getPolynomialDegree}()}\\[4pt]
Return the polynomial degree of the reconstruction.\\[5pt]
\MyBox{void  \Method{setReferencePoint}(\hyperref[FVPoint2D]{\Class{FVPoint3D}<double>} P)}\\[4pt]
Set the reference point for the polynomial reconstruction.\\[5pt] 
\MyBox{void  \Method{setVectorVertex3D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})}\\[4pt]
Give the data associated to the Vextexs of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorEdge3D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})  }\\[4pt]
Give the data associated to the Edges of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorFace3D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u})  }\\[4pt]
Give the data associated to the Faces of the mesh.\\[5pt]
\MyBox{void  \Method{setVectorCell3D}(\hyperref[FVVect]{\Class{FVVect}<double>} \& \Parameter{u}) }\\[4pt]
Give the data associated to the Cells of the mesh.\\[5pt]
\MyBox{void  \Method{doConservativeMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function will respect
the mean value with respect to the Reference entity. Stencil must be provided with a reference entity
to use the method.\\[5pt]
\MyBox{void  \Method{computeConservativeCoef}()} \\[4pt]
Compute the coefficient of the conservative polynomial reconstruction. Method \Method{doConservativeMatrix} 
must have been executed once to compute the matrix associated to the vertex. Data must be provided via methods
\Method{setVectorVertex3D}, \Method{setVectorEdge3D}, \Method{setVectorFace3D} or \Method{setVectorCell13D} 
in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{void  \Method{doMatrix}()}\\[4pt]
Compute the Matrix and do the QR factorization with respect to the stencil. The final polynomial function is the 
interpolation of the values in the Least square meaning. Stencil must be provided to use the method but no reference
element is require. Reference Point is the Origin by default bu should be modified with \Method{setReferencePoint}.\\[5pt]
\MyBox{void  \Method{computeCoef}()} \\[4pt]
Compute the coefficient of the polynomial reconstruction. Method \Method{doMatrix} must have been executed once
to compute the matrix associated to the vertex. Data must be provided via methods  \Method{setVectorVertex3D},
 \Method{setVectorEdge3D},  \Method{setVectorFace3D}or \Method{setVectorCell3D} 
in function of the geometrical entities used in the stencil.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{double getValue(\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} getDerivative(\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} \Parameter{P}, size\_t \Parameter{d})} \\[4pt]   
Compute the polynomial derivatives at point \Parameter{P} of degree \Parameter{d}. \Parameter{d} must be lower or equal
to the degree of the polynomial reconstruction.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} getDerivative(\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>} P)}  \\[4pt]
Same thing as above but we assume \Parameter{d} is the polynomial reconstruction degree.\\[5pt]
{\headline Function.}\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}}{\tt <size\_t>} \Function{alpha3D}({\tt size\_t} \Parameter{k})}\\[4pt]
Return the power $\alpha(k)=(\alpha^1,\alpha^2,\alpha^3)$ associated to the monomial 
$p(x_1,x_2,x_3)=(x_1)^{\alpha^1}(x_2)^{\alpha^2}(x_3)^{\alpha^3}$
where \Parameter{k} ranges between $0$ and $d(d+1)(d+2)/6-1$, with $d$ the degree of the polynomial reconstruction.
This function is the fundamental link between the powers and their storage in a vector.\\[5pt]
{\headline Example.}\\[5pt]
\newpage
%
%===================== CLASS ================
%







\section{FVVertex1D}\label{FVVertex1D}
\centerline{\Class{\tt FVVertex1D} Class Reference}
\begin{Description*}
Class for the one-dimensional vertex.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the vertex.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the vertex. \\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>}  \Field{coord} } \\[4pt]
The $x$-coordinate of the vertex.\\[5pt]
\MyBox{\hyperref[FVPoint1D]{\Class{FVPoint1D}<double>}  \Field{normal} } \\[4pt]
The $x$-coordinate of normal vector the vertex from left to right. The value is $-1$ or $1$.\\[5pt]
\MyBox{\hyperref[FVCell1D]{\Class{FVCell1D}} *\Field{leftCell},*\Field{rightCell}}\\[4pt] 
Pointer to the left and right cell of the edge. \Field{leftCell} is always the inner cell.
\Field{rightCell}{\tt =NULL} if the edge is on the boundary.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVCell1D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVCell1D}()}\\[4pt]
Destructor method.\\[5pt]


{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVVertex1D} *\Parameter{c1}, \Class{FVVertex1D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{c1} and \Parameter{c2} have the same labels.

{\headline Example.}\\[5pt]
\newpage
%
%===================== CLASS ================
%
\section{FVVertex2D}\label{FVVertex2D}
\centerline{\Class{FVVertex2D} Class Reference}

\begin{Description}
Class for the two-dimensional vertex.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the edge.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the edge. \\[5pt]
\MyBox{size\_t \Field{nb\_cell} }\\[4pt]
The number of cells which share the vertex. \\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}<double>}  \Field{coord} } \\[4pt]
The $(x,y)$-coordinates of the vertex.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} *\Field{cell}[NB\_CELL\_PER\_VERTEX\_2D]}\\[4pt] 
Pointer table to the cells which share the vertex from 0 to \Field{nb\_cell}-1. 
NB\_CELL\_PER\_VERTEX\_2D is the maximum number of cells in contact with the vertex 
defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVVertex2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVVertex2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} * \Method{beginCell}()}\\[4pt]
Initialize the internal pointer to the first cell in contact with the vertex and return the address.\\[5pt]
\MyBox{\hyperref[FVCell2D]{\Class{FVCell2D}} * \Method{nextCell}()}\\[4pt]
Return the pointer of the current cell and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
 
{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVVertex2D} *\Parameter{c1}, \Class{FVVertex2D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same labels.

{\headline Example.}

\newpage
%
%===================== CLASS ================
%
\section{FVVertex3D}\label{FVVertex3D}
\centerline{\Class{FVVertex3D} Class Reference}

\begin{Description}
Class for the three-dimensional vertex.
\hfill \hyperref[MainIndex]{\Index}
\end{Description}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the edge.\\[5pt]
\MyBox{size\_t \Field{code} }\\[4pt]
The code of the edge. \\[5pt]
\MyBox{size\_t \Field{nb\_cell} }\\[4pt]
The number of cells which share the vertex. \\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}<double>}  \Field{coord} } \\[4pt]
The $(x,y,z)$-coordinates of the vertex.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} *\Field{cell}[NB\_CELL\_PER\_VERTEX\_3D]}\\[4pt] 
Pointer table to the cells which share the vertex from 0 to \Field{nb\_cell}-1. 
NB\_CELL\_PER\_VERTEX\_3D is the maximum number of cells in contact with the vertex 
defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVVertex3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVVertex3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} * \Method{beginCell}()}\\[4pt]
Initialize the internal pointer to the first cell in contact with the vertex and return the address.\\[5pt]
\MyBox{\hyperref[FVCell3D]{\Class{FVCell3D}} * \Method{nextCell}()}\\[4pt]
Return the pointer of the current cell and move to the next one. If we reach the end of
the list, return {\tt NULL}.\\[5pt]
 
{\headline Function.}\\[5pt]
\MyBox{inline bool \Function{isEqual}(\Class{FVVertex3D} *\Parameter{c1}, \Class{FVVertex3D}*\Parameter{c2})}\\[4pt]
Return {\bf \tt true} if \Parameter{\tt c1} and \Parameter{\tt c2} have the same labels.

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{GMElement}\label{GMElement}
\centerline{\Class{GMElement} Class Reference}
\begin{Description*}
Class to handle gmsh element.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{label} }\\[4pt]
The label of the element.\\[5pt]
\MyBox{size\_t \Field{code\_physical} }\\[4pt]
The physical code of the element. \\[5pt]
\MyBox{size\_t \Field{code\_elementary} }\\[4pt]
The elementary code of the element. \\[5pt]
\MyBox{size\_t \Field{type\_element} }\\[4pt]
The type of the element using the nomenclature of \gmsh. \\[5pt]
\MyBox{size\_t \Field{nb\_node} }\\[4pt]
The number of node associated to the element. \\[5pt]
\MyBox{size\_t \Field{dim} }\\[4pt]
The space dimension associted to the element. \\[5pt] 
\MyBox{size\_t \Field{node}[GMSH\_NB\_NODE\_PER\_ELEMENT] }\\[4pt]
Table which contains the label of the element nodes.;
GMSH\_NB\_NODE\_PER\_ELEMENT is the maximum number of nodes for a \Class{GMElement}
defined in file \hyperref[FVLib_config]{\File{FVLib\_config.h}}.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{GMElement}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$GMElement}()}\\[4pt]
Destructor method.\\[5pt]

{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{Gmsh}\label{Gmsh}
\centerline{\Class{Gmsh} Class Reference}
\begin{Description*}
Class to handle gmsh mesh and output for post-processing with gmsh.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]

\MyBox{\Method{Gmsh}()}\\[4pt]
Default Constructor method.\\[5pt]
\MyBox{\Method{Gmsh}(const char * \Parameter{filename})}\\[4pt]
Constructor method which load the \hyperref[MeshFormat]{\FVlib} format mesh  in file \Parameter{filename}.\\[5pt]
\MyBox{void \Method{readMesh}(const char * \Parameter{filename})}\\[4pt]
Open a file and load the \hyperref[MeshFormat]{\gmsh} format mesh in file \Parameter{filename}.\\[5pt] 
\MyBox{void \Method{writeMesh}(const char * \Parameter{filename})}\\[4pt]
Open a file and write the current mesh on disk with the \hyperref[MeshFormat]{\gmsh} format in file \Parameter{filename}.\\[5pt]
\MyBox{void \Method{close}()}\\[4pt]
Close the current file.\\[5pt]
\MyBox{size\_t \Method{getNbNode}()}\\[4pt]
Return the number of nodes of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getNbElement}()}\\[4pt]
Return the number of elements of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{size\_t \Method{getDim}()}\\[4pt]
Return the dimension of the mesh. Return 0 if no mesh is present.\\[5pt] 
\MyBox{void \Method{FVMesh2Gmsh}(\hyperref[FVMesh1D]{\Class{FVMesh1D}} \&ms)};\\[4pt] 
Convert a \hyperref[FVMesh1D]{\Class{FVMesh1D}} into a \Class{Gmsh}.\\[5pt] 
\MyBox{void \Method{FVMesh2Gmsh}(\hyperref[FVMesh2D]{\Class{FVMesh2D}} \&ms)};\\[4pt] 
Convert a \hyperref[FVMesh2D]{\Class{FVMesh2D}} into a \Class{Gmsh}.\\[5pt] 
\MyBox{void \Method{FVMesh2Gmsh}(\hyperref[FVMesh3D]{\Class{FVMesh3D}} \&ms)};\\[4pt] 
Convert a \hyperref[FVMesh3D]{\Class{FVMesh3D}} into a \Class{Gmsh}.\\[5pt] 
\MyBox{\hyperref[FVVertex3D]{\Class{FVVertex3D}} * \Method{getNode}(const size\_t i)}.\\[4pt]
Return the pointer of Node \hyperref[FVVertex3D]{\Class{FVVertex3D}([i]} 
from 0 to \Method{getNbNode}-1.\\[5pt] 
\MyBox{\hyperref[GMElement]{\Class{GMElement}} * \Method{getElement}(const size\_t i)}.\\[4pt]
Return the pointer of  element \hyperref[GMElement]{\Class{GMElement}[i]} 
from 0 to \Method{getNbElement}-1.\\[5pt] 
\MyBox{
\begin{minipage}{14cm}
void \Method{writeVector}(\hyperref[FVVect]{\Class{FVVect}}<double> \&, const size\_t \Parameter{type},
const char *\Parameter{name}, double \Parameter{time})
\end{minipage}
       }.\\[4pt]
Write vector in the current \gmsh\ file. 
\begin{itemize}
\item The file has to be opened and the mesh written with method \Method{writeMesh}. 
Then, one can write the vector. 
\item \Parameter{type} must be {\tt VERTEX} to write  a vector of length
\Method{getNbNode} (vertex centered value) or {\tt CELL} to write  a vector of length
\Method{getNbElement} (cell centered value). 
\item   \Parameter{name} characterizes the field. \gmsh\ deals with the name in the followinf way.
In the same file, the fields with the same name are gathered in the same view with their respective time.
In that way, it is possible to show a field for different time step.
The fields with different name are displayed in different view.
\item \Parameter{time} The time associated to the field.
\end{itemize}
\MyBox{
\begin{minipage}{14cm}
void \Method{writeVector}(\hyperref[FVVect]{\Class{FVVect}}<double> \&, 
\hyperref[FVVect]{\Class{FVVect}}<double> \&,
const size\_t \Parameter{type},
const char *\Parameter{name}, double \Parameter{time})
\end{minipage}
       }.\\[4pt]
Write vectors in the current \gmsh\ file. Usualy to show 2D vectorial field. The other parameters
are similar to the previous method.\\[5pt] 
\MyBox{
\begin{minipage}{14cm}
void \Method{writeVector}(\hyperref[FVVect]{\Class{FVVect}}<double> \&, 
\hyperref[FVVect]{\Class{FVVect}}<double> \&,\hyperref[FVVect]{\Class{FVVect}}<double> \&,
const size\_t \Parameter{type},
const char *\Parameter{name}, double \Parameter{time})
\end{minipage}
       }.\\[4pt]
Write vectors in the current \gmsh\ file. Usualy to show 3D vectorial field. The other parameters
are similar to the previous method.\\[5pt] 

    % void writeVector(const FVVect<double> &,const FVVec\endt<double> &,  const size_t type,const char *name, double time);    
    % void writeVector(const FVVect<double> &,const FVVect<double> &, const FVVect<double> &, const size_t type,const char *name, double time); 
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\newpage

\chapter{Vector and Matrix}
\newpage
%
%===================== CLASS ================
%
\section{FVDenseM}\label{FVDenseM}

\begin{Description*}
Class for dense matrix.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{valarray<T\_>\Field{a} }\\[4pt]
The matrice. We can directly acces to the matrix coefficients with {\tt a[i]} from 0 to \Field{lenght}-1.
Caution. We have $a_{ij}=${\tt a[nb\_cols*(i-1)+(j-1)]} with $i=1,..,$\Field{nb\_cols} 
and $j=1,..,$\Field{nb\_rows}.\\[5pt]
\MyBox{size\_t \Field{nb\_rows} }\\[4pt]
The number of rows of the matrix.\\[5pt]
\MyBox{size\_t \Field{nb\_cols} }\\[4pt]
The number of columns of the matrix.\\[5pt]
\MyBox{size\_t \Field{lenght} }\\[4pt]
The length=\Field{nb\_rows}$\times$\Field{nb\_cols} of the matrix.\\[5pt]

{\headline Method.}\\[5pt]
\MyBox{\Method{FVDenseM}()}\\[4pt]
Default Constructor method.Construct a matrix of length=0.\\[5pt]
\MyBox{\Method{FVDenseM}(size\_t \Parameter{n})}\\[4pt]
Constructor method of a \Parameter{n}$\times$\Parameter{n} square matrix.\\[5pt]
\MyBox{\Method{FVDenseM}(size\_t \Parameter{n},size\_t \Parameter{m})}\\[4pt]
Constructor method of a \Parameter{n}$\times$\Parameter{m} rectangular matrix.\\[5pt]
\MyBox{\Method{FVDenseM}(const \Class{FVDenseM}<T\_> \&)}\\[4pt]
Copy constructor.\\[5pt]
\MyBox{size\_t \Method{getNbColumns}()}\\[4pt]
Return the number of colums of the  matrix.\\[5pt]
\MyBox{size\_t \Method{getNbRows}()}\\[4pt]
Return the number of rows of the  matrix.\\[5pt]
\MyBox{size\_t \Method{getLength}()}\\[4pt]
Return the number of coefficients of the  matrix.\\[5pt]
\MyBox{valarray<T\_> * \Method{getTab}()}\\[4pt]
Return the matrix {\tt a} as a {tt valarray} vector.\\[5pt]
\MyBox{void \Method{resize}(size\_t \Parameter{n})}\\[4pt]
Reallocate memory to provide a \Parameter{n} square matrix.\\[5pt]
\MyBox{void \Method{resize}(size\_t \Parameter{n}, size\_t \Parameter{m})}\\[4pt]
Reallocate memory to provide a \Parameter{n}$\times$\Parameter{m} rectangular matrix.\\[5pt]
\MyBox{void \Method{setValue}(size\_t \Parameter{i}, size\_t \Parameter{j}, const T\_ \& \Parameter{val})}\\[4pt]
Set {\tt a[nb\_cols*i+j]=val} where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{void \Method{addValue}(size\_t \Parameter{i}, size\_t \Parameter{j}, const T\_ \& \Parameter{val})}\\[4pt]
Add {\tt a[nb\_cols*i+j]+=val} where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{T\_ \Method{getValue}(size\_t \Parameter{i}, size\_t \Parameter{j})}\\[4pt]
Return {\tt a[nb\_cols*i+j]} where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{void \Method{setLine}(size\_t \Parameter{i}, 
            \hyperref[FVVect]{\Class{FVVect}}<double> \& \Parameter{vec})}\\[4pt]
Set the \Parameter{i} line of matrix with vector \Parameter{vec}. Length of the vector must be equal to the number
of rows.\\[5pt]
\MyBox{void \Method{setColumn}( size\_t \Parameter{j}, 
            \hyperref[FVVect]{\Class{FVVect}}<double> \& \Parameter{vec} )}\\[4pt]
Set the \Parameter{j} column of matrix with vector \Parameter{vec}. Length of the vector must be equal to the number
of lines.\\[5pt]

\MyBox{void \Method{show}()}\\[4pt]
Print the matrix elements on the standard output (console).\\[5pt]
%   the resolution method
\MyBox{void \Method{Gauss}(\hyperref[FVVect]{\Class{FVVect}}<double> \& \Parameter{b})}\\[4pt]
Perform the resolution of the linear problem using the Gauss with partial pivoting method for a generic
\hyperref[FVVect]{\Class{FVVect}} vector. Return the solution
in \Parameter{b}.\\[5pt]
\MyBox{void \Method{Gauss}(\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> \& \Parameter{b})}\\[4pt]
Perform the resolution of the linear problem using the Gauss with partial pivoting method for a 
\hyperref[FVPoint2D]{\Class{FVPoint2D}} element. Return the solution in \Parameter{b}.\\[5pt]
\MyBox{void \Method{Gauss}(\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> \& \Parameter{b})}\\[4pt]
Perform the resolution of the linear problem using the Gauss with partial pivoting methodfor a 
\hyperref[FVPoint3D]{\Class{FVPoint3D}} element. Return the solution
in \Parameter{b}.\\[5pt]
\MyBox{void \Method{Gauss}(\hyperref[FVPoint4D]{\Class{FVPoint4D}}<double> \& \Parameter{b})}\\[4pt]
Perform the resolution of the linear problem using the Gauss with partial pivoting methodfor a 
\hyperref[FVPoint4D]{\Class{FVPoint4D}} element. Return the solution
in \Parameter{b}.\\[5pt]
% LU   
\MyBox{void \Method{LUFactorize}()}\\[4pt]
Perform the $A=LU$ factorization for a square matrix $A$. The $U$ upper matrix substitutes the $A$ upper part
including the diagonal while the $L$ lower matrix substitutes the lower part of $A$. one value diagonal is assumed
for $L$.\\[5pt]
\MyBox{void \Method{ForwardSubstitution}(\hyperref[FVVect]{\Class{FVVect}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ly=b$ resolution assuming one value diagonal. At the end, vector \Parameter{b} 
contains the solution $y$ \\[5pt]
\MyBox{void \Method{ForwardSubstitution}(\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ly=b$ resolution assuming one value diagonal. At the end, \Class{FVPoint2D} \Parameter{b} 
contains the solution $y$. The dimension of the square matrix must be equal to 2.\\[5pt]
\MyBox{void \Method{ForwardSubstitution}(\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ly=b$ resolution assuming one value diagonal. At the end, \Class{FVPoint3D} \Parameter{b} 
contains the solution $y$. The dimension of the square matrix must be equal to 3.\\[5pt]
\MyBox{void \Method{ForwardSubstitution}(\hyperref[FVPoint4D]{\Class{FVPoint4D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ly=b$ resolution assuming one value diagonal. At the end, \Class{FVPoint4D} \Parameter{b} 
contains the solution $y$. The dimension of the square matrix must be equal to 4.\\[5pt]
\MyBox{void \Method{BackwardSubstitution}(\hyperref[FVVect]{\Class{FVVect}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ux=b$ resolution. At the end, vector \Parameter{b} 
contains the solution $x$ \\[5pt]
\MyBox{void \Method{BackwardSubstitution}(\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ux=b$ resolution. At the end, \Class{FVPoint2D} \Parameter{b} 
contains the solution $x$ The dimension of the square matrix must be equal to 2. \\[5pt]
\MyBox{void \Method{BackwardSubstitution}(\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ux=b$ resolution. At the end, \Class{FVPoint3D} \Parameter{b} 
contains the solution $x$ The dimension of the square matrix must be equal to 3. \\[5pt]
\MyBox{void \Method{BackwardSubstitution}(\hyperref[FVPoint4D]{\Class{FVPoint4D}}<double> \& \Parameter{b}) }\\[4pt]
Perform the $Ux=b$ resolution. At the end, \Class{FVPoint4D} \Parameter{b} 
contains the solution $x$ The dimension of the square matrix must be equal to 4. \\[5pt]
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=LU factorization with FVDenseM matrix]
size_t nb=4;            
FVDenseM<double> A(nb);
FVVect<double> b(nb);
// assuming that A and b are initialized
A.LUFactorize();
A.ForwardSubstitution(b); //solve Ly=b
A.BackwardSubstitution(b); //solve Ux=y
\end{lstlisting}
\MyBox{void \Method{QRFactorize}(\Class{FVDenseM}<double> \& \Parameter{QT})}\\[4pt]
Perform the $A=QR$ factorization for a over-determined matrix $A$ using the Householder method. 
The $R$ upper matrix substitutes the $A$ upper part including the diagonal the lower part is set to zero.
while the \Parameter{QT}  matrix is an orthogonal which contains {\bf the transposed} matrix $Q$.\\[5pt]
\MyBox{void \Method{PartialBackwardSubstitution}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{b})}\\[4pt]
Perform the $Ux=b$ resolution with a upper over-determined system. At the end, vector \Parameter{b} 
contains the solution $x$ \\[5pt]
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=QR factorization with FVDenseM matrix]
size_t nr=4,nc=3;         
FVDenseM<double> A(nr,nc), QT(nr);
FVVect<double> b(nr),y(nr);
// assuming that A and b are initialized
A.QRFactorize(QT);
QT.Mult(b,y);  // attention QT is still the transposed matrix
A.PartialBackwardSubstitution(y); //solve Rx=y with R 
                                  //upper rectangular matrix over-determined
\end{lstlisting}
{\headline Operator.}\\[5pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator+=}(const \Class{FVDenseM}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator-=}(const \Class{FVDenseM}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVDenseM}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVDenseM} matrix]
FVDenseM<double> A(3,4), B(3,4);
double x;
A=B; // copy constructeur
A=x; // set all the coefficients with x
A+=B; // add B to A
A-=B; // substract B to A
A+=x; // add x to all the coefficients of A
A-=x; // substract x to all the coefficients of A
A*=x; // multiply x to all the coefficients of A
A/=x; // divide all the coefficients of A with x
\end{lstlisting}
\MyBox{void \Method{Mult}(const \hyperref[FVVect]{\Class{FVVect}}<T\_> \&x,\hyperref[FVVect]{\Class{FVVect}}<T\_> \&y) const}\\[4pt]
Compute $y=Ax$. The length of $x$ must be equal to the number of columns of A.
The length of $y$ must be equal to the number of rows of A.\\[5pt]
\MyBox{void \Method{TransMult}(const \hyperref[FVVect]{\Class{FVVect}}<T\_> \&,\hyperref[FVVect]{\Class{FVVect}}<T\_> \&) const}\\[4pt]
Compute $y=A^tx$.The length of $x$ must be equal to the number of rows of A.
The length of $y$ must be equal to the number of columns of A.
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operation with FVDenseM matrix]
FVDenseM<double> A(3,4);
FVVect<double> x(4),y(3);
A.Mult(x,y); //Compute y=A x
A.TransMult(y,x);  //Compute x=A^t y
\end{lstlisting}
{\headline Function.}\\[5pt]
No extern function for this class.\\[5pt]

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVSparseM}\label{FVSparseM}
\begin{Description*}
Class for spare matrix. 
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}
{\headline Field.}\\[5pt]
\MyBox{size\_t \Field{nb\_rows} }\\[4pt]
The number of rows of the matrix.\\[5pt]
\MyBox{size\_t \Field{nb\_cols} }\\[4pt]
The number of columns of the matrix.\\[5pt]
\MyBox{size\_t \Field{lenght} }\\[4pt]
The length of non null element of the matrix.\\[5pt]
{\headline Method.}\\[5pt]
\MyBox{\Method{FVSparseM}()}\\[4pt]
Default Constructor method.Construct a matrix of length=0.\\[5pt]
\MyBox{\Method{FVSparseM}(size\_t \Parameter{n})}\\[4pt]
Constructor method of a \Parameter{n}$\times$\Parameter{n} square matrix.\\[5pt]
\MyBox{\Method{FVSparseM}(size\_t \Parameter{n},size\_t \Parameter{m})}\\[4pt]
Constructor method of a \Parameter{n}$\times$\Parameter{m} rectangular matrix.\\[5pt]
\MyBox{\Method{FVSparseM}(const \Class{FVSparseM}<T\_> \&)}\\[4pt]
Copy constructor.\\[5pt]
\MyBox{size\_t \Method{getNbColumns}()}\\[4pt]
Return the number of colums of the  matrix.\\[5pt]
\MyBox{size\_t \Method{getNbRows}()}\\[4pt]
Return the number of rows of the  matrix.\\[5pt]
\MyBox{size\_t \Method{getLength}()}\\[4pt]
Return the number of non-null coefficients of the  matrix.\\[5pt]
\MyBox{void \Method{resize}(size\_t \Parameter{n})}\\[4pt]
Reallocate memory to provide a \Parameter{n} square matrix.\\[5pt]
\MyBox{void \Method{resize}(size\_t \Parameter{n}, size\_t \Parameter{m})}\\[4pt]
Reallocate memory to provide a \Parameter{n}$\times$\Parameter{m} rectangular matrix.\\[5pt]
\MyBox{void \Method{setValue}(size\_t \Parameter{i}, size\_t \Parameter{j}, const T\_ \& \Parameter{val})}\\[4pt]
Set \Parameter{val} in position $(i,j)$ where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{void \Method{addValue}(size\_t \Parameter{i}, size\_t \Parameter{j}, const T\_ \& \Parameter{val})}\\[4pt]
Add \Parameter{val} in position $(i,j)$ where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{void \Method{ResizeAndsetValue}(size\_t \Parameter{i}, size\_t \Parameter{j}, const T\_ \& \Parameter{val})}\\[4pt]
Resize the matrix if $i$ or $j$ are greater to the current number of rows or columns.
Then set \Parameter{val} in position $(i,j)$ where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{T\_ \Method{getValue}(size\_t \Parameter{i}, size\_t \Parameter{j})}\\[4pt]
Return \Parameter{val} in position $(i,j)$  where {\tt i=0,...,nb\_rows-1} and {\tt j=0,...,nb\_cols-1}.\\[5pt]
\MyBox{void \Method{show}()}\\[4pt]
Print the matrix elements on the standard output (console).\\[5pt]
{\headline Operator.}\\[5pt]
\MyBox{\Class{FVSparseM}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVSparseM}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVSparseM} matrix]
FVSparseM<double> A(3,4), B(3,4);
double x;
A*=x; // multiply x to all the coefficients of A
A/=x; // divide all the coefficients of A with x
\end{lstlisting}
\MyBox{void \Method{Mult}(const \hyperref[FVVect]{\Class{FVVect}}<T\_> \&x,\hyperref[FVVect]{\Class{FVVect}}<T\_> \&y) const}\\[4pt]
Compute $y=Ax$. The length of $x$ must be equal to the number of columns of A.
The length of $y$ must be equal to the number of rows of A.\\[5pt]
\MyBox{void \Method{TransMult}(const \hyperref[FVVect]{\Class{FVVect}}<T\_> \&,\hyperref[FVVect]{\Class{FVVect}}<T\_> \&) const}\\[4pt]
Compute $y=A^tx$.The length of $x$ must be equal to the number of rows of A.
The length of $y$ must be equal to the number of columns of A.
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operation with FVDenseM matrix]
FVSparseM<double> A(3,4);
FVVect<double> x(4),y(3);
x=1;y=0;
A.setValue(1,0,11.4);A.setValue(0,3,3.14);
A.Mult(x,y); //Compute y=A x
A.TransMult(y,x);  //Compute x=A^t y
\end{lstlisting}
{\headline Function.}\\[5pt]
No extern function for this class.\\[5pt]
{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVVect}\label{FVVect}
\begin{Description*}
Class for vector.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVVect<T\_>}()}\\[4pt]
Default Constructor method. Construct a matrix of length=0.\\[5pt]
\MyBox{\Method{FVVect<T\_>}(size\_t \Parameter{n})}\\[4pt]
Construct a vector of length \Parameter{n}.\\[5pt]
\MyBox{\Method{FVVect<T\_>}(const \Class{FVVect}<T\_>\& )}
Copy constructor.\\[5pt]
\MyBox{size\_t\Method{size}()}\\[4pt]
Return the length of vector.\\[5pt]
\MyBox{void \Method{resize}(size\_t \Parameter{n})}\\[4pt]
Reallocate memory to provide a \Parameter{n} length vector.\\[5pt]
\MyBox{<T\_> \Method{beginElement}()}\\[4pt]
Set the iterator pointer at the beginning of the vector.\\[5pt]
\MyBox{<T\_> \Method{nextElement}()}\\[4pt]
Return the element and move the pointer to the next element. Return NULL if reaching the end of the vector.\\[5pt]
\MyBox{void \Method{show}()}\\[4pt]
Print the vector elements on the standard output (console).\\[5pt]
{\headline Operator.}\\[5pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator+=}(const \Class{FVVect}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator-=}(const \Class{FVVect}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVVect}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVVect}]
FVVect<double> U(3), V(3);
double x;
U=V; // copy constructeur
U=x; // set all the coefficient with x
U+=V; // add V to U
U-=V; // substract V to U
U+=x; // add x to all the coefficient of U
U-=x; // substract x to all the coefficient of U
U*=x; // multiply x to all the coefficient of U
U/=x; // divide all the coefficient of U with x
\end{lstlisting}
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=access to the vectors]
FVVect<double> U(100), V(100);
double dots=0.;
for(size_t i=0;i<100;i++)
    dots+=U[i]*V[i];
\end{lstlisting}
\newpage
\chapter{Tools}
\newpage
%
%===================== CLASS ================
%
\section{FVGaussPoint1D}\label{FVGaussPoint1D}
\begin{Description*}
Class to determine the Gauss point for integration of a 1D segment.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
The class contains no field.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVGaussPoint1D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVGaussPoint1D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{size\_t \Method{getNbPoint}(size\_t \Parameter{d})}\\[4pt]
Return the number of point use for the quadrature formula of order \Parameter{d}.\\[5pt]
\MyBox{double \Method{getWeight}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the weight for the quadrature formula of order \Parameter{d} and the \Parameter{p} points.\\[5pt]
\MyBox{\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double>  \Method{getPoint}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the barycentric coordinates for the \Parameter{p} points for the quadrature formula of order \Parameter{d}.\\[5pt]
{\headline Operator.}\\[5pt]
No operator for this class\\[5pt]
{\headline Function.}\\[5pt]
No function are defined for this class.\\[5pt]
{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=quadrature formula 1D]
FVVertex1D v1,v2;
FVGaussPoint1D G1D;
size_t order=3;
// f(double) is a known function we integrate
double integral=0;
FVPoint2D<double> GP;
for(size_t i=0;i<G1D.getNbPoint();i++)
    {
    GP=G1D.getPoint(d,i);
    intergral+=G1D.getWeight(d,i)*f(GP.x*v1.coord+GP.y*v2.coord);
    }
integral*=// length segment;
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{FVGaussPoint2D}\label{FVGaussPoint2D}
\begin{Description*}
Class to determine the Gauss point for integration of a 2D triangle.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
The class contains no field.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVGaussPoint2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVGaussPoint2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{size\_t \Method{getNbPoint}(size\_t \Parameter{d})}\\[4pt]
Return the number of point use for the quadrature formula of order \Parameter{d}.\\[5pt]
\MyBox{double \Method{getWeight}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the weight for the quadrature formula of order \Parameter{d} and the \Parameter{p} points.\\[5pt]
\MyBox{\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double>  \Method{getPoint}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the barycentric coordinates for the \Parameter{p} points for the quadrature formula of order \Parameter{d}.\\[5pt]
{\headline Operator.}\\[5pt]
No operator for this class\\[5pt]
{\headline Function.}\\[5pt]
No function are defined for this class.\\[5pt]
{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=quadrature formula 2D]
FVVertex2D v1,v2,v3;
FVGaussPoint2D G2D;
size_t order=3;
// f(double) is a known function we integrate
double integral=0;
FVPoint3D<double> GP;
for(size_t i=0;i<G2D.getNbPoint();i++)
    {
    GP=G2D.getPoint(d,i);
    intergral+=G2D.getWeight(d,i)*
               f(GP.x*v1.coord+GP.y*v2.coord+GP.z*v3.coord);
    }
integral*=//surface triangle;
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{FVGaussPoint3D}\label{FVGaussPoint3D}
\begin{Description*}
Class to determine the Gauss point for integration of a 3D tetrahedron.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
The class contains no field.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVGaussPoint3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVGaussPoint3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{size\_t \Method{getNbPoint}(size\_t \Parameter{d})}\\[4pt]
Return the number of point use for the quadrature formula of order \Parameter{d}.\\[5pt]
\MyBox{double \Method{getWeight}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the weight for the quadrature formula of order \Parameter{d} and the \Parameter{p} points.\\[5pt]
\MyBox{\hyperref[FVPoint4D]{\Class{FVPoint4D}}<double>  \Method{getPoint}(size\_t \Parameter{d},size\_t \Parameter{p})}\\[4pt]
Return the barycentric coordinates for the \Parameter{p} points for the quadrature formula of order \Parameter{d}.\\[5pt]
{\headline Operator.}\\[5pt]
No operator for this class\\[5pt]
{\headline Function.}\\[5pt]
No function are defined for this class.\\[5pt]
{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=quadrature formula 3D]
FVVertex2D v1,v2,v3,v4;
FVGaussPoint3D G3D;
size_t order=5;
// f(double) is a known function we integrate
double integral=0;
FVPoint4D<double> GP;
for(size_t i=0;i<G3D.getNbPoint();i++)
    {
    GP=G3D.getPoint(d,i);
    intergral+=G3D.getWeight(d,i)*
               f(GP.x*v1.coord+GP.y*v2.coord+GP.z*v3.coord+GP.t*v4.coord);
    }
integral*=//volume tetrahedron;
\end{lstlisting}
\newpage

%
%===================== CLASS ================
%
\section{FVio}\label{FVio}
\begin{Description*}
Class to read or write vector in files.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVio}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVio}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{void \Method{setTime}(double \&\Parameter{time})}\\[4pt]
Set the time value.\\[5pt]
\MyBox{void \Method{setName}(string \&\Parameter{name})} \\[4pt]
Set the name for the current instance.\\[5pt]
\MyBox{void \Method{open}(const char *\Parameter{namefile}, int \Parameter{mode})}\\[4pt]
Open the file \Parameter{namefile} to read a file if \Parameter{mode}{\tt =FVREAD} or write a file if
 \Parameter{mode}{\tt =FVWRITE}.\\[5pt]
\MyBox{void \Method{close}()}\\[4pt]
Close the file.\\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{put}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u}, 
       const double \Parameter{time}=0.,const string \&\Parameter{name}="noname")
\end{minipage}
}\\[4pt]   
Write the vector \Parameter{u} of cast {\tt double} using the \hyperref[VectorFormat]{\FVlib\ format}
for the time   \Parameter{time} (default=0.) and name \Parameter{name} (default="noname").
 \Parameter{time} and \Parameter{name} are optional. 
The file must be opened with mode {\tt FVWRITE}.\\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{put}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u}, 
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
       const double \Parameter{time}=0.,const string \&\Parameter{name}="noname")
\end{minipage}
}\\[4pt]
Write vectors \Parameter{u,v} of cast {\tt double}. Same options as mentioned above. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{put}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u}, 
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{w},
       const double \Parameter{time}=0.,const string \&\Parameter{name}="noname")
\end{minipage}
}\\[4pt]
Write vectors \Parameter{u,v,w} of cast {\tt double}. Same options as mentioned above. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{put}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> >\&
                 \Parameter{u}, const double \Parameter{time}=0., const string \&\Parameter{name}="noname")
\end{minipage}
}\\[4pt]
Write vectors \Parameter{u} of cast {\tt\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double>}. 
Same options as mentioned above. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{put}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> >\&
                 \Parameter{u}, const double \Parameter{time}=0., const string \&\Parameter{name}="noname")
\end{minipage}
}\\[4pt]
Write vectors \Parameter{u} of cast {\tt\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double>}. 
Same options as mentioned above. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{w},
                  double \&\Parameter{time}, string \&\Parameter{name});
\end{minipage}
}\\[4pt]
Read the file and get vectors \Parameter{u,v,w}, the time \Parameter{time} and the name \Parameter{name}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{w},
                  double \&\Parameter{time});
\end{minipage}
}\\[4pt]
Read the file and get vectors \Parameter{u,v,w} and the time \Parameter{time}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{w});
\end{minipage}
}\\[4pt]
Read the file and get vectors \Parameter{u,v,w}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
\begin{minipage}{14cm}
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  double \&\Parameter{time}, string \&\Parameter{name});
\end{minipage}
}\\[4pt]
Read the file and get vectors \Parameter{u,v}, the time \Parameter{time} and the name \Parameter{name}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v},
                  double \&\Parameter{time});
}\\[4pt]
Read the file and get vectors \Parameter{u,v} and the time \Parameter{time}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  \hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{v});
}\\[4pt]
Read the file and get vectors \Parameter{u,v}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  double \&\Parameter{time}, string \&\Parameter{name});
}\\[4pt]
Read the file and get vectors \Parameter{u}, the time \Parameter{time} and the name \Parameter{name}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u},
                  double \&\Parameter{time});
}\\[4pt]
Read the file and get vectors \Parameter{u} and the time \Parameter{time}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<double> \&\Parameter{u});
}\\[4pt]
Read the file and get vectors \Parameter{u}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]   
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> >
      \&\Parameter{u}, double \&\Parameter{time}, string \&\Parameter{name});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint2D]{\Class{FVPoint2D}}<double>}, 
the time \Parameter{time} and the name \Parameter{name}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> >
      \&\Parameter{u}, double \&\Parameter{time});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint2D]{\Class{FVPoint2D}}<double>} 
and the time \Parameter{time}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint2D]{\Class{FVPoint2D}}<double> >
      \&\Parameter{u});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint2D]{\Class{FVPoint2D}}<double>}.
The file must be open with the {\tt FVREAD} mode. \\[5pt] 
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> >
      \&\Parameter{u}, double \&\Parameter{time}, string \&\Parameter{name});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint3D]{\Class{FVPoint3D}}<double>}, 
the time \Parameter{time} and the name \Parameter{name}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> >
      \&\Parameter{u}, double \&\Parameter{time});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint3D]{\Class{FVPoint3D}}<double>} 
and the time \Parameter{time}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{
void \Method{get}(\hyperref[FVVect]{\Class{FVVect}}<\hyperref[FVPoint3D]{\Class{FVPoint3D}}<double> >
      \&\Parameter{u});
}\\[4pt]
Read the file and get vectors \Parameter{u} of cast {\tt \hyperref[FVPoint3D]{\Class{FVPoint3D}}<double>}.
The file must be open with the {\tt FVREAD} mode. \\[5pt]
\MyBox{ size\_t \Method{getNbVect}()}\\[4pt]
Return the current number of componant of the vector after read or write a \Format{xml} file. \\[5pt]
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVPoint1D}\label{FVPoint1D}
\begin{Description*}
Class to manipulate one-dimensional points such as coordinates.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{T\_ \Field{x} }\\[4pt]
Components of the points. Template {\tt T\_} will be a double, a float or a complex number.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVPoint1D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVPoint1D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVPoint1D}(const \Class{FVPoint1D}<T\_>\& )}
Copy constructor.

{\headline Operator.}\\[5pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator+=}(const \Class{FVPoint2D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator-=}(const \Class{FVPoint2D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint1D}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
\MyBox{void \Method{show}();}\\[4pt]
Display the ome-dimensional point on the current console.\\[5pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint1D}]
FVPoint1D<double> P, Q;
double val;
P=Q; // copy constructeur
P=val; // set all the coefficient with val
P+=Q; // add P to Q
P-=Q; // substract Q to P
P+=val; // add val to all the coefficient of P
P-=val; // substract val to all the coefficient of P
P*=val; // multiply val to all the coefficient of P
P/=val; // divide all the coefficient of P with val
\end{lstlisting}
{\headline Function.}\\[5pt]
\MyBox{inline double \Function{Norm}(const \Class{FVPoint1D}<double> \&\Parameter{u})}\\[4pt]
Return Euclidian norm of \Parameter{u}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint1D}<T\_> \Function{operator+}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const \Class{FVPoint1D}<T\_> \&\Parameter{b}) 
\end{minipage}
}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}+\Parameter{b}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint1D}<T\_> \Function{operator-}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const \Class{FVPoint2D}<T\_> \&\Parameter{b})
\end{minipage} 
}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}-\Parameter{b}.\\[5pt]
\MyBox{template <class T\_> T\_ \Function{operator*}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const \Class{FVPoint1D}<T\_> \&\Parameter{b}) }\\[4pt]
Return the template {\tt T\_} which corresponds to the dot product between \Parameter{a} and \Parameter{b}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint1D}<T\_>\Function{operator-}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a})}\\[4pt]
Return the \Class{FVPoint1D} -\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint1D}<T\_>\Function{operator+}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}+\Parameter{x} where we add \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint1D}<T\_>\Function{operator-}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}-\Parameter{x} where we substract \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint1D}<T\_>\Function{operator*}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}*\Parameter{x} where we multiply \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint1D}<T\_>\Function{operator/}
(const \Class{FVPoint1D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint1D} \Parameter{a}/\Parameter{x} where we divide  each componants of
\Parameter{a} with \Parameter{x}.

\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint1D}]
FVPoint1D<double> P,Q,R;
double val;
P=Q+R;
P=Q-R;
val=P*Q;// the dot product
val=norm(P); the Euclidian norm
P=-Q;
P=Q+val;
P=Q-val;
P=Q*val;
P=Q/val
\end{lstlisting}
{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVPoint2D}\label{FVPoint2D}
\begin{Description*}
Class to manipulate two-dimensional points such as coordinates.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{T\_ \Field{x,y} }\\[4pt]
Components of the points. Template {\tt T\_} will be a double, a float or a complex number.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVPoint2D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVPoint2D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVPoint2D}(const \Class{FVPoint2D}<T\_>\& )}
Copy constructor.

{\headline Operator.}\\[5pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator+=}(const \Class{FVPoint2D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator-=}(const \Class{FVPoint2D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint2D}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
\MyBox{void \Method{show}();}\\[4pt]
Display the two-dimensional point on the current console.\\[5pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint2D}]
FVPoint2D<double> P, Q;
double val;
P=Q; // copy constructeur
P=val; // set all the coefficient with val
P+=Q; // add P to Q
P-=Q; // substract Q to P
P+=val; // add val to all the coefficient of P
P-=val; // substract val to all the coefficient of P
P*=val; // multiply val to all the coefficient of P
P/=val; // divide all the coefficient of P with val
\end{lstlisting}
{\headline Function.}\\[5pt]

\MyBox{inline double \Function{Det}(const \Class{FVPoint2D}<double> \&\Parameter{u},
                                    const \Class{FVPoint2D}<double> \&\Parameter{v})}\\[4pt]
Return the determinant of the $2\times2$ matrix constituted with \Parameter{u} and \Parameter{v}.\\[5pt]
\MyBox{inline double \Function{Norm}(const \Class{FVPoint2D}<double> \&\Parameter{u})}\\[4pt]
Return Euclidian norm of \Parameter{u}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint2D}<T\_> \Function{operator+}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const \Class{FVPoint2D}<T\_> \&\Parameter{b}) 
\end{minipage}
}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}+\Parameter{b}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint2D}<T\_> \Function{operator-}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const \Class{FVPoint2D}<T\_> \&\Parameter{b})
\end{minipage} 
}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}-\Parameter{b}.\\[5pt]
\MyBox{template <class T\_> T\_ \Function{operator*}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const \Class{FVPoint2D}<T\_> \&\Parameter{b}) }\\[4pt]
Return the template {\tt T\_} which corresponds to the dot product between \Parameter{a} and \Parameter{b}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint2D}<T\_>\Function{operator-}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a})}\\[4pt]
Return the \Class{FVPoint2D} -\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint2D}<T\_>\Function{operator+}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}+\Parameter{x} where we add \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint2D}<T\_>\Function{operator-}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}-\Parameter{x} where we substract \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint2D}<T\_>\Function{operator*}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}*\Parameter{x} where we multiply \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint2D}<T\_>\Function{operator/}
(const \Class{FVPoint2D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint2D} \Parameter{a}/\Parameter{x} where we divide  each componants of
\Parameter{a} with \Parameter{x}.

\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint2D}]
FVPoint2D<double> P,Q,R;
double val;
P=Q+R;
P=Q-R;
val=P*Q;// the dot product
val=det(P,Q);// the determinant
val=norm(P); the Euclidian norm
P=-Q;
P=Q+val;
P=Q-val;
P=Q*val;
P=Q/val
\end{lstlisting}
{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{FVPoint3D}\label{FVPoint3D}
\begin{Description*}
Class to manipulate three-dimensional points such as coordinates.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{T\_ \Field{x,y,z} }\\[4pt]
Components of the points. Template {\tt T\_} will be a double, a float or a complex number.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVPoint3D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVPoint3D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVPoint3D}(const \Class{FVPoint3D}<T\_>\& )}
Copy constructor.

{\headline Operator.}\\[5pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator+=}(const \Class{FVPoint3D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator-=}(const \Class{FVPoint3D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint3D}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
\MyBox{void \Method{show}();}\\[4pt]
Display the three-dimensional point on the current console.\\[5pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint3D}]
FVPoint3D<double> P, Q;
double val;
P=Q; // copy constructeur
P=val; // set all the coefficient with val
P+=Q; // add P to Q
P-=Q; // substract Q to P
P+=val; // add val to all the coefficient of P
P-=val; // substract val to all the coefficient of P
P*=val; // multiply val to all the coefficient of P
P/=val; // divide all the coefficient of P with val
\end{lstlisting}
{\headline Function.}\\[5pt]

\MyBox{
\begin{minipage}{16cm}
inline double \Function{Det}(const \Class{FVPoint3D}<double> \&\Parameter{u},
                                    const \Class{FVPoint3D}<double> \&\Parameter{v},
                                    const \Class{FVPoint3D}<double> \&\Parameter{w})
\end{minipage}
}\\[4pt]
Return the determinant of the $3\times3$ matrix constituted with \Parameter{u,v} and \Parameter{w}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
inline \Class{FVPoint3D}<double> \Function{CrossProduct}(const \Class{FVPoint3D}<double> \&\Parameter{u},
                                    const \Class{FVPoint3D}<double> \&\Parameter{v})
\end{minipage}
}\\[4pt]
Return the cross product \Class{FVPoint3D} constituted with \Parameter{u} and \Parameter{v}.\\[5pt]
\MyBox{inline double \Function{Norm}(const \Class{FVPoint3D}<double> \&\Parameter{u})}\\[4pt]
Return Euclidian norm of \Parameter{u}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint3D}<T\_> \Function{operator+}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const \Class{FVPoint3D}<T\_> \&\Parameter{b}) 
\end{minipage}
}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}+\Parameter{b}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint3D}<T\_> \Function{operator-}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const \Class{FVPoint3D}<T\_> \&\Parameter{b})
\end{minipage} 
}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}-\Parameter{b}.\\[5pt]
\MyBox{template <class T\_> T\_ \Function{operator*}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const \Class{FVPoint3D}<T\_> \&\Parameter{b}) }\\[4pt]
Return the template {\tt T\_} which corresponds to the dot product between \Parameter{a} and \Parameter{b}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator-}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a})}\\[4pt]
Return the \Class{FVPoint3D} -\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator+}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}+\Parameter{x} where we add \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator-}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}-\Parameter{x} where we substract \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator*}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}*\Parameter{x} where we multiply \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator/}
(const \Class{FVPoint3D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}/\Parameter{x} where we divide  each componants of
\Parameter{a} with \Parameter{x}.

\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint3D}]
FVPoint3D<double> P,Q,R;
double val;
P=Q+R;
P=Q-R;
val=P*Q;// the dot product
val=det(P,Q);// the determinant
val=norm(P); the Euclidian norm
P=-Q;
P=Q+val;
P=Q-val;
P=Q*val;
P=Q/val
\end{lstlisting}
{\headline Example.}
\newpage

%
%===================== CLASS ================
%
\section{FVPoint4D}\label{FVPoint4D}
\begin{Description*}
Class to manipulate four-dimensional points such as coordinates and time.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
\MyBox{T\_ \Field{x,y,z,t} }\\[4pt]
Components of the points. Template {\tt T\_} will be a double, a float or a complex number.

{\headline Method.}\\[5pt]
\MyBox{\Method{FVPoint4D}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$FVPoint4D}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{FVPoint4D}(const \Class{FVPoint4D}<T\_>\& )}
Copy constructor.

{\headline Operator.}\\[5pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator+=}(const \Class{FVPoint4D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator-=}(const \Class{FVPoint4D}<T\_> \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator/=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator*=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator+=}(const T\_ \&)}\\[4pt]
\MyBox{\Class{FVPoint4D}<T\_> \& \Method{operator-=}(const T\_ \&)}\\[4pt]
\MyBox{void \Method{show}();}\\[4pt]
Display the four-dimensional point on the current console.\\[5pt]
The following operations are available
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint4D}]
FVPoint4D<double> P, Q;
double val;
P=Q; // copy constructeur
P=val; // set all the coefficient with val
P+=Q; // add P to Q
P-=Q; // substract Q to P
P+=val; // add val to all the coefficient of P
P-=val; // substract val to all the coefficient of P
P*=val; // multiply val to all the coefficient of P
P/=val; // divide all the coefficient of P with val
\end{lstlisting}
{\headline Function.}\\[5pt]

%\MyBox{
%\begin{minipage}{16cm}
%inline double \Function{Det}(const \Class{FVPoint4D}<double> \&\Parameter{u},
%                                    const \Class{FVPoint4D}<double> \&\Parameter{v},
%                                    const \Class{FVPoint4D}<double> \&\Parameter{w})
%\end{minipage}
%}\\[4pt]
%Return the determinant of the $3\times3$ matrix constituted with \Parameter{u,v} and \Parameter{w}.\\[5pt]
%\MyBox{
%\begin{minipage}{15cm}
%inline \Class{FVPoint3D}<double> \Function{CrossProduct}(const \Class{FVPoint3D}<double> \&\Parameter{u},
%                                    const \Class{FVPoint3D}<double> \&\Parameter{v})
%\end{minipage}
%}\\[4pt]
%Return the cross product \Class{FVPoint3D} constituted with \Parameter{u} and \Parameter{v}.\\[5pt]
\MyBox{inline double \Function{Norm}(const \Class{FVPoint4D}<double> \&\Parameter{u})}\\[4pt]
Return Euclidian norm of \Parameter{u}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint4D}<T\_> \Function{operator+}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const \Class{FVPoint4D}<T\_> \&\Parameter{b}) 
\end{minipage}
}\\[4pt]
Return the \Class{FVPoint4D} \Parameter{a}+\Parameter{b}.\\[5pt]
\MyBox{
\begin{minipage}{15cm}
template <class T\_> \Class{FVPoint4D}<T\_> \Function{operator-}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const \Class{FVPoint4D}<T\_> \&\Parameter{b})
\end{minipage} 
}\\[4pt]
Return the \Class{FVPoint4D} \Parameter{a}-\Parameter{b}.\\[5pt]
\MyBox{template <class T\_> T\_ \Function{operator*}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const \Class{FVPoint4D}<T\_> \&\Parameter{b}) }\\[4pt]
Return the template {\tt T\_} which corresponds to the dot product between \Parameter{a} and \Parameter{b}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint4D}<T\_>\Function{operator-}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a})}\\[4pt]
Return the \Class{FVPoint4D} -\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint4D}<T\_>\Function{operator+}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint4D} \Parameter{a}+\Parameter{x} where we add \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint3D}<T\_>\Function{operator-}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint3D} \Parameter{a}-\Parameter{x} where we substract \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint4D}<T\_>\Function{operator*}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint4D} \Parameter{a}*\Parameter{x} where we multiply \Parameter{x} to each componants of
\Parameter{a}.\\[5pt]
\MyBox{template <class T\_> \Class{FVPoint4D}<T\_>\Function{operator/}
(const \Class{FVPoint4D}<T\_> \&\Parameter{a}, const T\_ \&\Parameter{x})}\\[4pt]
Return the \Class{FVPoint4D} \Parameter{a}/\Parameter{x} where we divide  each componants of
\Parameter{a} with \Parameter{x}.

\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=available operations with \Class{FVPoint4D}]
FVPoint4D<double> P,Q,R;
double val;
P=Q+R;
P=Q-R;
val=P*Q;// the dot product
val=norm(P); the Euclidian norm
P=-Q;
P=Q+val;
P=Q-val;
P=Q*val;
P=Q/val
\end{lstlisting}
{\headline Example.}
\newpage
%
%===================== CLASS ================
%
\section{Parameter}\label{Parameter}

\begin{Description*}
Class to read parameter from a \hyperref[ParameterFormat]{\Class{Parameter} file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{Parameter}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$Parameter}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{Parameter}(const char *\Parameter{filename})}\\[4pt]
Read and sparse the file  \Parameter{filename}. The file must respect the
\hyperref[ParameterFormat]{\Class{Parameter} file format}. \\[5pt]
\MyBox{double \Method{getDouble}(const string \&\Parameter{key})}\\[4pt]
Return the double value associated to the \Parameter{key}.
If \Parameter{key} is not present in the file, a error message is displayed. \\[5pt]
\MyBox{int \Method{getInteger}(const string \&\Parameter{key})}\\[4pt]
Return the sign integer value associated to the \Parameter{key}.
If \Parameter{key} is not present in the file, a error message is displayed. \\[5pt]
\MyBox{size\_t \Method{getUnsigned}(const string \&\Parameter{key})}\\[4pt]
Return the unsigned integer value associated to the \Parameter{key}.
If \Parameter{key} is not present in the file, a error message is displayed. \\[5pt]
\MyBox{string \Method{getString}(const string \&\Parameter{key})}\\[4pt]
Return the string associated to the \Parameter{key}.
If \Parameter{key} is not present in the file, a error message is displayed. \\[5pt]
\MyBox{double \Method{getDouble}(const char  *\Parameter{key})}\\[4pt]
Same function but \Parameter{key} is a {\tt const char *} in place of a string. \\[5pt]
\MyBox{int \Method{getInteger}(const char  *\Parameter{key})}\\[4pt]
Same function but \Parameter{key} is a {\tt const char *} in place of a string. \\[5pt]
\MyBox{size\_t \Method{getUnsigned}(const char  *\Parameter{key})}\\[4pt]
Same function but \Parameter{key} is a {\tt const char *} in place of a string. \\[5pt]
\MyBox{string \Method{getstring}(const char  *\Parameter{key})}\\[4pt]
Same function but \Parameter{key} is a {\tt const char *} in place of a string. \\[5pt]
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\begin{lstlisting}[frame=TB,framerule=0.3pt,caption=read and use a \Class{Parameter} file]
Parameter param("my_parameters.xml");
double val=param.getDouble("density");
string name=param.getString("FileName");
size_t NbNode=param.getUnsigned("NumberOfNodes");
\end{lstlisting}
\newpage
%
%===================== CLASS ================
%
\section{Table}\label{Table}
\begin{Description*}
Class to read and handle tables contained a \hyperref[TableFormat]{\Class{Table} file format}.
\hfill \hyperref[MainIndex]{\Index}
\end{Description*}

{\headline Field.}\\[5pt]
All the fields are {\bf \tt private}.

{\headline Method.}\\[5pt]
\MyBox{\Method{Table}()}\\[4pt]
Constructor method.\\[5pt]
\MyBox{\Method{$\sim$Table}()}\\[4pt]
Destructor method.\\[5pt]
\MyBox{\Method{Table}(const char *\Parameter{filename})}\\[4pt]
Read and sparse the file  \Parameter{filename}. The file must respect the
\hyperref[ParameterFormat]{\Class{Table} file format}. \\[5pt]
\MyBox{size\_t  \Method{getNbPoints1}()}\\[4pt]
Return the number of point for the first indice. \\[5pt]
\MyBox{size\_t  \Method{getNbPoints2}()}\\[4pt]
Return the number of point for the second indice. \\[5pt]
\MyBox{size\_t  \Method{getNbPoints3}()}\\[4pt]
Return the number of point for the third indice. \\[5pt]
\MyBox{double \Method{getMin1}()}\\[4pt]
Return the minimal value for the first variable. \\[5pt]
\MyBox{double \Method{getMin2}()}\\[4pt]
Return the minimal value for the second variable. \\[5pt]
\MyBox{double \Method{getMin13}()}\\[4pt]
Return the minimal value for the third variable. \\[5pt]
\MyBox{double \Method{getMax1}()}\\[4pt]
Return the maximal value for the first variable. \\[5pt]
\MyBox{double \Method{getMax2}()}\\[4pt]
Return the maximal value for the second variable. \\[5pt]
\MyBox{double \Method{getMax3}()}\\[4pt]
Return the maximal value for the third variable. \\[5pt]
\MyBox{double \Method{linearInterpolation}(double \Parameter{x})}\\[4pt]
Return the interpolate value of a one-dimension \Class{Table}.
If \Parameter{x} is outside of the range, the function return the closest value
which belongs to the convex hull.\\[5pt]
\MyBox{double \Method{linearInterpolation}(double \Parameter{x},double \Parameter{y})}\\[4pt]
Return the interpolate value of a two-dimension \Class{Table}.
If \Parameter{x,y} are outside of the range, the function return the closest value
which belongs to the convex hull.\\[5pt]
\MyBox{double \Method{linearInterpolation}(double \Parameter{x},double \Parameter{y},double \Parameter{z})}\\[4pt]
Return the interpolate value of a three-dimension \Class{Table}.
If \Parameter{x,y,z} are outside of the range, the function return the closest value
which belongs to the convex hull.\\[5pt]
\MyBox{double \Method{linearExtrapolation}(double \Parameter{x})}\\[4pt]
Return the interpolate value of a one-dimension \Class{Table}.
If \Parameter{x} is outside of the range, the function return an extrapolated value.\\[5pt]
\MyBox{double \Method{linearExtrapolation}(double \Parameter{x},double \Parameter{y})}\\[4pt]
Return the interpolate value of a two-dimension \Class{Table}.
If \Parameter{x,y} are outside of the range, the function return an extrapolated value.\\[5pt]
\MyBox{double \Method{linearExtrapolation}(double \Parameter{x},double \Parameter{y},double \Parameter{z})}\\[4pt]
Return the interpolate value of a three-dimension \Class{Table}.
If \Parameter{x,y,z} are outside of the range, the function return an extrapolated value.\\[5pt]
{\headline Function.}\\[5pt]
No extern function for this class

{\headline Example.}
\newpage
%\section{XML}\label{XML}
%\begin{Description*}
%Class to handle gmsh mesh and output for post-processing with gmsh.
%\end{Description*}

%{\headline Field.}\\[5pt]
%All the fields are {\bf \tt private}.

%{\headline Method.}\\[5pt]
%{\headline Function.}\\[5pt]
%No extern function for this class

%{\headline Example.}
%\newpage
\chapter{Configuration files}
\newpage
\section{FVLib\_config}\label{FVLib_config}   
Include file which contains  the {\tt \#define} of \FVlib.
\lstinputlisting[language=C++]{../include/FVLib_config.h}
\section{FVGlobal}\label{FVGlobal}
Include file which contains  the global variables of \FVlib.
\lstinputlisting[language=c++]{../include/FVGlobal.h}
\part{The finite volume layer} 
\end{document}